<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChatHistoryState">
    <option name="serializedSessions">
      <map>
        <entry key="714f5644-3cee-41a5-a4ad-f8f4e3aa9c9a" value="{&quot;id&quot;:&quot;714f5644-3cee-41a5-a4ad-f8f4e3aa9c9a&quot;,&quot;name&quot;:&quot;[TextContent(type\u003dtext, text\u003d\n\u003cadditional_data\u003e\nBelow are some potentially helpful/relevant pieces of information for figuring out to respond\n\u003ccurrent_file\u003e\n```kotlin:app/src/main/java/com/example/hungdm/service/AppService.kt, lines\u003dALL(1-101)\npackage com.example.hungdm.service\n\nimport android.content.Intent\nimport android.media.MediaPlayer\nimport android.net.Uri\nimport android.util.Log\nimport androidx.lifecycle.LifecycleService\n\nclass AppService : LifecycleService() {\n\n    companion object {\n        const val ACTION_PLAY \u003d \&quot;action_play\&quot;\n        const val ACTION_PAUSE \u003d \&quot;action_pause\&quot;\n        const val ACTION_RESUME \u003d \&quot;action_resume\&quot;\n        const val ACTION_CLOSE \u003d \&quot;action_close\&quot;\n        const val EXTRA_URI \u003d \&quot;extra_uri\&quot;\n    }\n\n    private var mediaPlayer: MediaPlayer? \u003d null\n    private var currentUri: Uri? \u003d null\n\n    override fun onCreate() {\n        super.onCreate()\n        Log.d(\&quot;tag\&quot;,\&quot;oncreate play\&quot;)\n    }\n\n    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {\n        super.onStartCommand(intent, flags, startId)\n        when (intent?.action) {\n            ACTION_PLAY -\u003e {\n                val uri \u003d intent.getParcelableExtra\u003cUri\u003e(EXTRA_URI)\n                Log.d(\&quot;tag\&quot;,\&quot;onStartCommand play\&quot;)\n                uri?.let {\n                    playMusic(it)\n                }\n            }\n            ACTION_PAUSE -\u003e {\n                pauseMusic()\n            }\n            ACTION_CLOSE -\u003e {\n                stopMusic()\n            }\n            ACTION_RESUME -\u003e {\n                resumeMusic()\n            }\n        }\n        return START_STICKY\n    }\n\n    override fun onDestroy() {\n        mediaPlayer?.release()\n        mediaPlayer \u003d null\n        super.onDestroy()\n    }\n\n    private fun playMusic(uri: Uri) {\n        try {\n            mediaPlayer?.release()\n            mediaPlayer \u003d MediaPlayer().apply {\n                setDataSource(applicationContext, uri)\n                prepare()\n                start()\n                isLooping \u003d false\n            }\n            currentUri \u003d uri\n            startForeground(\n                1,\n\n            )\n        } catch (e: Exception) {\n            e.printStackTrace()\n        }\n    }\n\n    private fun pauseMusic() {\n        mediaPlayer?.pause()\n        startForeground(\n            1,\n\n        )\n    }\n\n    private fun stopMusic() {\n        mediaPlayer?.stop()\n        mediaPlayer?.release()\n        stopSelf()\n    }\n\n    private fun resumeMusic() {\n        mediaPlayer?.let {\n            if (!it.isPlaying) {\n                it.start()\n                startForeground(\n                    1,\n\n                )\n            }\n        }\n    }\n}\n\n```\n\u003c/current_file\u003e\n\n\n\u003clinter_errors\u003e\n## Linter Errors\n\nPath: app/src/main/java/com/example/hungdm/service/AppService.kt\nErrors:\n\nLine 66: None of the following functions can be called with the arguments supplied: \npublic final fun startForeground(id: Int, notification: Notification, foregroundServiceType: Int): Unit defined in com.example.hungdm.service.AppService\npublic final fun startForeground(id: Int, notification: Notification!): Unit defined in com.example.hungdm.service.AppService\nLine 77: None of the following functions can be called with the arguments supplied: \npublic final fun startForeground(id: Int, notification: Notification, foregroundServiceType: Int): Unit defined in com.example.hungdm.service.AppService\npublic final fun startForeground(id: Int, notification: Notification!): Unit defined in com.example.hungdm.service.AppService\nLine 93: None of the following functions can be called with the arguments supplied: \npublic final fun startForeground(id: Int, notification: Notification, foregroundServiceType: Int): Unit defined in com.example.hungdm.service.AppService\npublic final fun startForeground(id: Int, notification: Notification!): Unit defined in com.example.hungdm.service.AppService\n\u003c/linter_errors\u003e\n\u003c/additional_data\u003e\n\u003cuser_query\u003e\nstartForeground()\nxây dựng otification gồm nút next, previous, pause/resume, close. close thì tắt service, next thì phát bài nhạc tiếp theo, previous thì phát bài nhạc trước đo\n\u003c/user_query\u003e)]&quot;,&quot;timestamp&quot;:1754735429537,&quot;messages&quot;:[{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;\n\u003cadditional_data\u003e\nBelow are some potentially helpful/relevant pieces of information for figuring out to respond\n\u003ccurrent_file\u003e\n```kotlin:app/src/main/java/com/example/hungdm/service/AppService.kt, lines\u003dALL(1-101)\npackage com.example.hungdm.service\n\nimport android.content.Intent\nimport android.media.MediaPlayer\nimport android.net.Uri\nimport android.util.Log\nimport androidx.lifecycle.LifecycleService\n\nclass AppService : LifecycleService() {\n\n    companion object {\n        const val ACTION_PLAY \u003d \&quot;action_play\&quot;\n        const val ACTION_PAUSE \u003d \&quot;action_pause\&quot;\n        const val ACTION_RESUME \u003d \&quot;action_resume\&quot;\n        const val ACTION_CLOSE \u003d \&quot;action_close\&quot;\n        const val EXTRA_URI \u003d \&quot;extra_uri\&quot;\n    }\n\n    private var mediaPlayer: MediaPlayer? \u003d null\n    private var currentUri: Uri? \u003d null\n\n    override fun onCreate() {\n        super.onCreate()\n        Log.d(\&quot;tag\&quot;,\&quot;oncreate play\&quot;)\n    }\n\n    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {\n        super.onStartCommand(intent, flags, startId)\n        when (intent?.action) {\n            ACTION_PLAY -\u003e {\n                val uri \u003d intent.getParcelableExtra\u003cUri\u003e(EXTRA_URI)\n                Log.d(\&quot;tag\&quot;,\&quot;onStartCommand play\&quot;)\n                uri?.let {\n                    playMusic(it)\n                }\n            }\n            ACTION_PAUSE -\u003e {\n                pauseMusic()\n            }\n            ACTION_CLOSE -\u003e {\n                stopMusic()\n            }\n            ACTION_RESUME -\u003e {\n                resumeMusic()\n            }\n        }\n        return START_STICKY\n    }\n\n    override fun onDestroy() {\n        mediaPlayer?.release()\n        mediaPlayer \u003d null\n        super.onDestroy()\n    }\n\n    private fun playMusic(uri: Uri) {\n        try {\n            mediaPlayer?.release()\n            mediaPlayer \u003d MediaPlayer().apply {\n                setDataSource(applicationContext, uri)\n                prepare()\n                start()\n                isLooping \u003d false\n            }\n            currentUri \u003d uri\n            startForeground(\n                1,\n\n            )\n        } catch (e: Exception) {\n            e.printStackTrace()\n        }\n    }\n\n    private fun pauseMusic() {\n        mediaPlayer?.pause()\n        startForeground(\n            1,\n\n        )\n    }\n\n    private fun stopMusic() {\n        mediaPlayer?.stop()\n        mediaPlayer?.release()\n        stopSelf()\n    }\n\n    private fun resumeMusic() {\n        mediaPlayer?.let {\n            if (!it.isPlaying) {\n                it.start()\n                startForeground(\n                    1,\n\n                )\n            }\n        }\n    }\n}\n\n```\n\u003c/current_file\u003e\n\n\n\u003clinter_errors\u003e\n## Linter Errors\n\nPath: app/src/main/java/com/example/hungdm/service/AppService.kt\nErrors:\n\nLine 66: None of the following functions can be called with the arguments supplied: \npublic final fun startForeground(id: Int, notification: Notification, foregroundServiceType: Int): Unit defined in com.example.hungdm.service.AppService\npublic final fun startForeground(id: Int, notification: Notification!): Unit defined in com.example.hungdm.service.AppService\nLine 77: None of the following functions can be called with the arguments supplied: \npublic final fun startForeground(id: Int, notification: Notification, foregroundServiceType: Int): Unit defined in com.example.hungdm.service.AppService\npublic final fun startForeground(id: Int, notification: Notification!): Unit defined in com.example.hungdm.service.AppService\nLine 93: None of the following functions can be called with the arguments supplied: \npublic final fun startForeground(id: Int, notification: Notification, foregroundServiceType: Int): Unit defined in com.example.hungdm.service.AppService\npublic final fun startForeground(id: Int, notification: Notification!): Unit defined in com.example.hungdm.service.AppService\n\u003c/linter_errors\u003e\n\u003c/additional_data\u003e\n\u003cuser_query\u003e\nstartForeground()\nxây dựng otification gồm nút next, previous, pause/resume, close. close thì tắt service, next thì phát bài nhạc tiếp theo, previous thì phát bài nhạc trước đo\n\u003c/user_query\u003e&quot;}]},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Bạn muốn xây dựng một notification media có các nút: Next, Previous, Pause/Resume, Close. Khi nhấn Close thì tắt Service, Next/Previous thì đổi bài nhạc, Pause/Resume thì điều khiển playback. Để thực hiện:\n\n1. **Tạo Notification với các nút điều khiển** (sử dụng NotificationCompat và các PendingIntent với các action phù hợp).\n2. **Cập nhật hàm startForeground()** để nhận Notification.\n3. **Xử lý các action trong Service (onStartCommand)**: Khi nhận action Next/Previous thì đổi bài nhạc (cần nguồn dữ liệu list nhạc); Pause/Resume như hiện tại; Close thì stopSelf.\n\nTôi sẽ sắp xếp lại mã, xây dựng hàm tạo Notification, bổ sung nút bấm và intent. Tuy nhiên, để phát bài tiếp theo/trước đó, bạn cần cung cấp danh sách nhạc hoặc logic quản lý list bài hát. Nếu chưa có, tôi sẽ giả lập bằng cấu trúc đơn giản.\n\nTôi sẽ chỉnh sửa file để:\n- Thêm hàm buildNotification().\n- Sửa lại các vị trí gọi startForeground().\n- Xử lý đầy đủ các action.\n\nBạn có muốn tôi mô phỏng danh sách nhạc bằng một mảng đơn giản cho Next/Previous không, hay bạn đã có dữ liệu bài hát?&quot;}]},{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;\n\u003cadditional_data\u003e\nBelow are some potentially helpful/relevant pieces of information for figuring out to respond\n\u003ccurrent_file\u003e\n```kotlin:app/src/main/java/com/example/hungdm/screen/mvi/MviContract.kt, lines\u003dALL(1-51)\npackage com.example.hungdm.screen.mvi\n\nimport android.content.Context\nimport com.example.hungdm.domain.model.Playlist\nimport com.example.hungdm.domain.model.Song\nimport com.example.hungdm.domain.model.UserInfo\n\ndata class MviState(\n    val darkTheme: Boolean \u003d true,\n    val userInfo: UserInfo \u003d UserInfo(),\n    val listSongLocal: List\u003cSong\u003e \u003d mutableListOf\u003cSong\u003e(),\n    val listSongRemote: List\u003cSong\u003e \u003d mutableListOf\u003cSong\u003e(),\n    val playlists: List\u003cPlaylist\u003e \u003d mutableListOf(),\n    val songPlay: Song? \u003d null,\n    val isPlay: Boolean \u003d false\n)\n\nsealed interface MviIntent{\n    data class GetUser(val userId: Long) : MviIntent\n    data object OnClickSignup : MviIntent\n    data class CheckLogin(val userInfo: UserInfo, val context: Context) : MviIntent\n    data class CheckSignup(val userInfo: UserInfo) : MviIntent\n    data object OnClickProfile: MviIntent\n    data class EditProfile(val userInfo: UserInfo) : MviIntent\n    data class LoadSongLocal(val context: Context) : MviIntent\n    data class LoadSongRemote(val context: Context) : MviIntent\n    data object LoadPlaylistsOfUser: MviIntent\n    data class CreatePlaylist(val title: String): MviIntent\n    data class RenamePlaylist(val title: String, val playlist: Playlist): MviIntent\n    data class RemovePlaylist(val playlist: Playlist): MviIntent\n    data class AddSongToPlaylist(val song: Song, val playlist: Playlist): MviIntent\n    data class RemoveSongInPlaylist(val song: Song, val playlist: Playlist): MviIntent\n    data class OnClickPlaylistDetail(val playlistId: Long) : MviIntent\n    data class OnClickSongPlay(val song: Song?, val context: Context) : MviIntent\n    data class OnChangeSongPlayState(val context: Context): MviIntent\n    data object ChangeTheme : MviIntent\n}\n\nsealed interface MviEvent{\n    data object GotoHome: MviEvent\n    data object GotoLogin: MviEvent\n    data object GotoSignup: MviEvent\n    data object GotoProfile: MviEvent\n    data class GotoPlaylistDetail(val playlistId: Long): MviEvent\n    data class ShowToast(val mess: String): MviEvent\n}\n\n\n\n\n\n```\n\u003c/current_file\u003e\n\n\n\u003cattached_files\u003e\n\u003cfile_contents\u003e\n```kotlin:app/src/main/java/com/example/hungdm/service/AppService.kt, lines\u003dALL(1-101)\n(file is identical to original version)\n```\n\u003c/file_contents\u003e\n\n\n\u003cfile_contents\u003e\n```kotlin:app/src/main/java/com/example/hungdm/service/PlayerState.kt, lines\u003dALL(1-32)\npackage com.example.hungdm.service\n\nimport com.example.hungdm.domain.model.Song\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.StateFlow\n\nobject PlayerState {\n    private val _playlist \u003d MutableStateFlow\u003cList\u003cSong\u003e\u003e(emptyList())\n    val playlist: StateFlow\u003cList\u003cSong\u003e\u003e \u003d _playlist\n\n    private val _currentIndex \u003d MutableStateFlow\u003cInt?\u003e(null)\n    val currentIndex: StateFlow\u003cInt?\u003e \u003d _currentIndex\n\n    private val _isPlaying \u003d MutableStateFlow(false)\n    val isPlaying: StateFlow\u003cBoolean\u003e \u003d _isPlaying\n\n    private val _position \u003d MutableStateFlow(0L)\n    val position: StateFlow\u003cLong\u003e \u003d _position\n\n    private val _duration \u003d MutableStateFlow(0L)\n    val duration: StateFlow\u003cLong\u003e \u003d _duration\n\n    fun setPlaylist(list: List\u003cSong\u003e, startIndex: Int \u003d 0) {\n        _playlist.value \u003d list\n        _currentIndex.value \u003d if (list.isEmpty()) null else startIndex.coerceIn(list.indices)\n    }\n\n    fun setCurrentIndex(index: Int?) { _currentIndex.value \u003d index }\n    fun setPlaying(playing: Boolean) { _isPlaying.value \u003d playing }\n    fun setPosition(pos: Long) { _position.value \u003d pos }\n    fun setDuration(d: Long) { _duration.value \u003d d }\n}\n```\n\u003c/file_contents\u003e\n\n\n\u003cfile_contents\u003e\n```kotlin:app/src/main/java/com/example/hungdm/screen/mvi/MviViewModel.kt, lines\u003dALL(1-414)\npackage com.example.hungdm.screen.mvi\n\nimport android.content.ContentUris\nimport android.content.Context\nimport android.content.Intent\nimport android.media.MediaMetadataRetriever\nimport android.net.Uri\nimport android.os.Build\nimport android.provider.MediaStore\nimport android.util.Log\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.example.hungdm.data.db.entity.PlaylistEntity\nimport com.example.hungdm.data.db.entity.PlaylistSongReference\nimport com.example.hungdm.data.mapper.toSong\nimport com.example.hungdm.domain.model.Playlist\nimport com.example.hungdm.domain.model.Song\nimport com.example.hungdm.domain.model.getAlbumArt\nimport com.example.hungdm.domain.repo.PlaylistRepository\nimport com.example.hungdm.domain.repo.UserRepository\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.flow.MutableSharedFlow\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.SharedFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.asSharedFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.withContext\nimport com.example.hungdm.utils.UserPreferences\nimport com.example.hungdm.data.mapper.toSongEntity\nimport com.example.hungdm.data.mapper.toUserEntity\nimport com.example.hungdm.data.mapper.toUserInfo\nimport com.example.hungdm.data.remote.ApiClient\nimport com.example.hungdm.service.AppService\nimport java.io.BufferedInputStream\nimport java.io.File\nimport java.io.FileOutputStream\nimport java.io.IOException\nimport java.net.HttpURLConnection\nimport java.net.URL\nimport java.net.UnknownHostException\n\nclass MviViewModel(\n    private val userRepository: UserRepository,\n    private val playlistRepository: PlaylistRepository\n) : ViewModel() {\n\n    private val _state \u003d MutableStateFlow\u003cMviState\u003e(MviState())\n    val state: StateFlow\u003cMviState\u003e \u003d _state.asStateFlow()\n    private val _event \u003d MutableSharedFlow\u003cMviEvent\u003e()\n    val event: SharedFlow\u003cMviEvent\u003e \u003d _event.asSharedFlow()\n\n    fun processIntent(intent: MviIntent) {\n        viewModelScope.launch  {\n            when (intent) {\n                is MviIntent.GetUser -\u003e {\n                    val user \u003d  withContext(Dispatchers.IO) {\n                        userRepository.getUserById(intent.userId)\n                    }\n                    _state.value \u003d _state.value.copy(userInfo \u003d user!!.toUserInfo())\n                }\n\n                is MviIntent.OnClickSignup -\u003e {\n                    sendEvent(MviEvent.GotoSignup)\n                }\n\n                is MviIntent.CheckLogin -\u003e {\n                    val user \u003d withContext(Dispatchers.IO) {\n                        userRepository.login(intent.userInfo.username, intent.userInfo.password)\n                    }\n\n                    if (user !\u003d null) {\n                        _state.value \u003d _state.value.copy(userInfo \u003d user.toUserInfo())\n                        UserPreferences.saveUser(intent.context, user.userId)\n                        sendEvent(MviEvent.GotoHome)\n                    } else {\n                        sendEvent(MviEvent.ShowToast(\&quot;Đăng nhập thất bại\&quot;))\n                    }\n                }\n\n                is MviIntent.CheckSignup -\u003e {\n                    val newUserInfo \u003d intent.userInfo\n                    try {\n                        val result \u003d withContext(Dispatchers.IO) {\n                            userRepository.signup(\n                                username \u003d newUserInfo.username,\n                                password \u003d newUserInfo.password,\n                                email \u003d newUserInfo.email\n                            )\n                        }\n                        if (result \u003e 0) {\n                            sendEvent(MviEvent.GotoLogin)\n                        } else {\n                            sendEvent(MviEvent.ShowToast(\&quot;Username đã tồn tại\&quot;))\n                        }\n                    } catch (e: Exception) {\n                        sendEvent(MviEvent.ShowToast(\&quot;Đăng ký thất bại: ${e.message}\&quot;))\n                    }\n                }\n\n                is MviIntent.OnClickProfile -\u003e {\n                    sendEvent(MviEvent.GotoProfile)\n                }\n\n                is MviIntent.EditProfile -\u003e {\n                    withContext(Dispatchers.IO) {\n                        userRepository.updateUser(intent.userInfo.toUserEntity())\n                    }\n                    _state.value \u003d _state.value.copy(userInfo \u003d intent.userInfo)\n                }\n\n                is MviIntent.ChangeTheme -\u003e {\n                    _state.value \u003d _state.value.copy(darkTheme \u003d !_state.value.darkTheme)\n                }\n\n                is MviIntent.LoadPlaylistsOfUser -\u003e {\n                    _state.value \u003d _state.value.copy(playlists \u003d loadPlaylistOfUser())\n                }\n\n                is MviIntent.LoadSongLocal -\u003e {\n                    val songs \u003d withContext(Dispatchers.IO) {\n                        getSongExternal(intent.context)\n                    }\n                    _state.value \u003d _state.value.copy(listSongLocal \u003d songs,)\n                }\n\n                is MviIntent.LoadSongRemote -\u003e {\n                    val dir \u003d File(intent.context.filesDir, _state.value.userInfo.username)\n                    if (!dir.exists()) {\n                        val songApi \u003d getSongRemote()\n                        //delay(1000) // neu k co delay thi songApi \u003d null, vi interface ApiService dunng Call\u003cList\u003cSongRemote\u003e\u003e\n                        val songInternal \u003d mutableListOf\u003cSong\u003e()\n                        withContext(Dispatchers.IO){\n                            for (i in songApi) {\n                                songInternal.add(\n                                    downloadSongToInternalStorage(\n                                        intent.context,\n                                        i.path!!,\n                                        _state.value.userInfo.username,\n                                        i.title + \&quot;.mp3\&quot;\n                                    )!!\n                                )\n                            }\n                        }\n                        _state.value \u003d _state.value.copy(listSongRemote \u003d songInternal)\n                    } else {\n                        val songs \u003d getALlSongInternal(intent.context, _state.value.userInfo.username)\n                        _state.value \u003d _state.value.copy(listSongRemote \u003d songs)\n                    }\n                }\n\n                is MviIntent.CreatePlaylist -\u003e {\n                    val playlistEntity \u003d PlaylistEntity(\n                        title \u003d intent.title,\n                        userId \u003d _state.value.userInfo.id\n                    )\n                    playlistRepository.createPlaylist(playlistEntity)\n                    _state.value \u003d _state.value.copy(playlists \u003d loadPlaylistOfUser())\n                }\n\n                is MviIntent.RenamePlaylist -\u003e {\n                    playlistRepository.renamePlaylist(intent.playlist.id, intent.title)\n                    _state.value \u003d _state.value.copy(\n                        playlists \u003d loadPlaylistOfUser()\n                    )\n                }\n\n                is MviIntent.RemovePlaylist -\u003e {\n                    playlistRepository.removePlaylist(intent.playlist.id)\n                    playlistRepository.removeAllSongInPlaylist(intent.playlist.id)\n                    _state.value \u003d _state.value.copy(playlists \u003d loadPlaylistOfUser())\n                }\n\n                is MviIntent.AddSongToPlaylist -\u003e {\n                    val id \u003d playlistRepository.addSong(intent.song.toSongEntity())\n                    playlistRepository.addSongToPlaylist(\n                        PlaylistSongReference(intent.playlist.id, id)\n                    )\n                    _state.value \u003d _state.value.copy(playlists \u003d loadPlaylistOfUser())\n                }\n\n                is MviIntent.RemoveSongInPlaylist -\u003e {\n                    playlistRepository.removeSongInPlaylist(intent.song.id, intent.playlist.id)\n                    _state.value \u003d _state.value.copy(playlists \u003d loadPlaylistOfUser())\n                }\n\n                is MviIntent.OnClickPlaylistDetail -\u003e {\n                    sendEvent(MviEvent.GotoPlaylistDetail(intent.playlistId))\n                }\n\n                is MviIntent.OnClickSongPlay -\u003e {\n                    if(intent.song\u003d\u003dnull){\n                        val tmp \u003d Intent(intent.context, AppService::class.java).apply {\n                            action \u003d AppService.ACTION_CLOSE\n                        }\n                        intent.context.startForegroundService(tmp)\n                        _state.value \u003d _state.value.copy(songPlay \u003d null, isPlay \u003d false)\n                    } else {\n                        val tmp \u003d Intent(intent.context, AppService::class.java).apply {\n                            action \u003d AppService.ACTION_PLAY\n                            putExtra(AppService.EXTRA_URI, intent.song.uri)\n                        }\n                        intent.context.startForegroundService(tmp)\n                        _state.value \u003d _state.value.copy(songPlay \u003d intent.song, isPlay \u003d true)\n                    }\n\n                }\n\n                is MviIntent.OnChangeSongPlayState -\u003e {\n                    if(_state.value.isPlay){\n                        val tmp \u003d Intent(intent.context, AppService::class.java).apply {\n                            action \u003d AppService.ACTION_PAUSE\n                        }\n                        intent.context.startForegroundService(tmp)\n                    } else {\n                        val tmp \u003d Intent(intent.context, AppService::class.java).apply {\n                            action \u003d AppService.ACTION_RESUME\n                        }\n                        intent.context.startForegroundService(tmp)\n                    }\n                    _state.value \u003d _state.value.copy(isPlay \u003d !_state.value.isPlay)\n                }\n            }\n        }\n    }\n\n    private fun sendEvent(event: MviEvent) {\n        viewModelScope.launch {\n            _event.emit(event)\n        }\n    }\n\n    private suspend fun loadPlaylistOfUser(): List\u003cPlaylist\u003e {\n        val playlists \u003d mutableListOf\u003cPlaylist\u003e()\n        withContext(Dispatchers.IO) {\n            val playlistWithSongsList \u003d\n                playlistRepository.getPlaylistsWithSongsOfUser(_state.value.userInfo.id)\n            playlistWithSongsList.map {\n                val songs \u003d it.songs.map { songEntity -\u003e\n                    Song(\n                        id \u003d songEntity.songId,\n                        title \u003d songEntity.title,\n                        artist \u003d songEntity.artist,\n                        duration \u003d songEntity.duration,\n                        uri \u003d songEntity.uri,\n                        img \u003d songEntity.img\n                    )\n                }\n                playlists.add(\n                    Playlist(\n                        id \u003d it.playlist.playlistId,\n                        title \u003d it.playlist.title,\n                        listSong \u003d songs.toMutableList()\n                    )\n                )\n            }\n        }\n        return playlists\n    }\n\n    private suspend fun getSongExternal(context: Context): MutableList\u003cSong\u003e {\n        val songs \u003d mutableListOf\u003cSong\u003e()\n        withContext(Dispatchers.IO) {\n            val uri \u003d MediaStore.Audio.Media.EXTERNAL_CONTENT_URI\n            val projection \u003d arrayOf(\n                MediaStore.Audio.Media._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.DURATION,\n                MediaStore.Audio.Albums.ALBUM_ID\n            )\n\n            val selection \u003d \&quot;${MediaStore.Audio.Media.IS_MUSIC} !\u003d 0\&quot;\n\n            val cursor \u003d context.contentResolver.query(\n                uri, projection, selection, null, null\n            )\n            cursor?.use {\n                val idColumn \u003d it.getColumnIndexOrThrow(MediaStore.Audio.Media._ID)\n                val titleColumn \u003d it.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE)\n                val artistColumn \u003d it.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST)\n                val durationColumn \u003d it.getColumnIndexOrThrow(MediaStore.Audio.Media.DURATION)\n                val albumIdColumn \u003d it.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM_ID)\n\n                while (it.moveToNext()) {\n                    val id \u003d it.getLong(idColumn)\n                    val title \u003d it.getString(titleColumn)\n                    val artist \u003d it.getString(artistColumn)\n                    val duration \u003d it.getLong(durationColumn)\n                    val albumId \u003d it.getLong(albumIdColumn)\n                    val songUri \u003d\n                        ContentUris.withAppendedId(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, id)\n                    val img \u003d getAlbumArt(context, albumId)\n                    songs.add(Song(id, title, artist, duration, songUri, img))\n                }\n            }\n        }\n        return songs\n    }\n\n    private suspend fun getALlSongInternal(context: Context, folderName: String): MutableList\u003cSong\u003e {\n        val songs \u003d mutableListOf\u003cSong\u003e()\n        val dir \u003d File(context.filesDir, folderName)\n        val mp3 \u003d dir.listFiles() ?: return mutableListOf()\n\n        withContext(Dispatchers.IO) {\n            val retriever \u003d MediaMetadataRetriever()\n            for (i in mp3) {\n                try {\n                    retriever.setDataSource(i.absolutePath)\n                    val title \u003d retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_TITLE)\n                        ?: i.nameWithoutExtension\n                    val artist \u003d retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ARTIST)\n                        ?: \&quot;Unknown Artist\&quot;\n                    val duration \u003d retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION)\n                        ?.toLongOrNull() ?: 0L\n                    val path \u003d i.absolutePath\n                    val img \u003d retriever.embeddedPicture\n                    songs.add(\n                        Song(\n                            title \u003d title,\n                            artist \u003d artist,\n                            duration \u003d duration,\n                            uri \u003d Uri.fromFile(i),\n                            img \u003d img,\n                            path \u003d path\n                        )\n                    )\n                } catch (e: Exception) {\n                    Log.d(\&quot;getSongInternal\&quot;, e.toString())\n                }\n            }\n        }\n        return songs\n    }\n\n    private suspend fun getSongRemote(): MutableList\u003cSong\u003e \u003d withContext(Dispatchers.IO) {\n        return@withContext try {\n            ApiClient.build().getSongRemote().map { it.toSong() }.toMutableList()\n        } catch (e: UnknownHostException) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Khong co mang: ${e.message}\&quot;)\n            mutableListOf()\n        } catch (e: IOException) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Loi IO: ${e.message}\&quot;)\n            mutableListOf()\n        } catch (e: Exception) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Loi khac: ${e.message}\&quot;)\n            mutableListOf()\n        }\n    }\n\n    private suspend fun downloadSongToInternalStorage(\n        context: Context,\n        fileUrl: String,\n        folderName: String,\n        fileName: String\n    ): Song? {\n        val dir \u003d File(context.filesDir, folderName)\n        if (!dir.exists()) dir.mkdir()\n        val file \u003d File(dir, fileName)\n        if (file.exists()) return null\n\n        return try {\n            var song: Song?\n            withContext(Dispatchers.IO){\n                val url \u003d URL(fileUrl)\n                val connection \u003d withContext(Dispatchers.IO) {\n                    url.openConnection()\n                } as HttpURLConnection\n                connection.connectTimeout \u003d 5000\n                connection.readTimeout \u003d 5000\n                connection.requestMethod \u003d \&quot;GET\&quot;\n                connection.doInput \u003d true\n                connection.connect()\n\n                if (connection.responseCode !\u003d HttpURLConnection.HTTP_OK) {\n                    throw IOException(\&quot;HTTP error code: ${connection.responseCode}\&quot;)\n                }\n\n                val inputStream \u003d BufferedInputStream(connection.inputStream)\n                val outputStream \u003d FileOutputStream(file)\n\n                inputStream.use { input -\u003e\n                    outputStream.use { output -\u003e\n                        input.copyTo(output)\n                    }\n                }\n\n                val retriever \u003d MediaMetadataRetriever()\n                retriever.setDataSource(file.absolutePath)\n\n                val title \u003d retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_TITLE) ?: file.nameWithoutExtension\n                val artist \u003d retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ARTIST) ?: \&quot;Unknown Artist\&quot;\n                val duration \u003d retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION)?.toLongOrNull() ?: 0L\n                val uri \u003d Uri.fromFile(file)\n                val img \u003d retriever.embeddedPicture\n                val path \u003d file.absolutePath\n                song \u003d Song(\n                    title \u003d title,\n                    artist \u003d artist,\n                    duration \u003d duration,\n                    uri \u003d uri,\n                    img \u003d img,\n                    path \u003d path\n                )\n            }\n            song\n        } catch (e: Exception) {\n            e.printStackTrace()\n            null\n        }\n    }\n}\n```\n\u003c/file_contents\u003e\n\n\u003c/attached_files\u003e\n\u003c/additional_data\u003e\n\u003cuser_query\u003e\nhãy làm viẹce đi\n\u003c/user_query\u003e&quot;}]},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Tôi sẽ tiến hành các bước sau để đáp ứng yêu cầu của bạn:\n\n1. Tạo hàm buildNotification với các nút Previous, Play/Pause, Next, Close.\n2. Sửa lại các dòng startForeground để luôn truyền vào Notification hợp lệ.\n3. Thêm xử lý các action NEXT, PREVIOUS trong Service bằng cách sử dụng danh sách và currentIndex từ PlayerState.\n4. Khi nhấn Close, Service sẽ tắt.\n\nDanh sách nhạc \u0026 chỉ số bài hiện tại sẽ lấy từ object PlayerState mà bạn đã có. Các action sẽ cập nhật index và gọi playMusic với Uri mới.\n\nTôi sẽ sửa file AppService.kt, tạo hàm buildNotification và cập nhật logic như sau.&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;call_Do6Z48L5F7fQQ7S35YqsZfIP&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;edit_file&quot;,&quot;arguments&quot;:&quot;{\&quot;target_file\&quot;:\&quot;app/src/main/java/com/example/hungdm/service/AppService.kt\&quot;,\&quot;instructions\&quot;:\&quot;Thêm notification media với nút next, previous, pause/resume, close. Sử dụng PlayerState và bổ sung xử lý action cho next/previous.\&quot;,\&quot;code_edit\&quot;:\&quot;// ... existing code ...\\n    companion object {\\n        const val ACTION_PLAY \u003d \\\&quot;action_play\\\&quot;\\n        const val ACTION_PAUSE \u003d \\\&quot;action_pause\\\&quot;\\n        const val ACTION_RESUME \u003d \\\&quot;action_resume\\\&quot;\\n        const val ACTION_CLOSE \u003d \\\&quot;action_close\\\&quot;\\n        const val ACTION_NEXT \u003d \\\&quot;action_next\\\&quot;\\n        const val ACTION_PREVIOUS \u003d \\\&quot;action_previous\\\&quot;\\n        const val EXTRA_URI \u003d \\\&quot;extra_uri\\\&quot;\\n    }\\n// ... existing code ...\\n    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {\\n        super.onStartCommand(intent, flags, startId)\\n        when (intent?.action) {\\n            ACTION_PLAY -\u003e {\\n                val uri \u003d intent.getParcelableExtra\u003cUri\u003e(EXTRA_URI)\\n                Log.d(\\\&quot;tag\\\&quot;,\\\&quot;onStartCommand play\\\&quot;)\\n                uri?.let {\\n                    playMusic(it)\\n                }\\n            }\\n            ACTION_PAUSE -\u003e {\\n                pauseMusic()\\n            }\\n            ACTION_CLOSE -\u003e {\\n                stopMusic()\\n            }\\n            ACTION_RESUME -\u003e {\\n                resumeMusic()\\n            }\\n            ACTION_NEXT -\u003e {\\n                playNext()\\n            }\\n            ACTION_PREVIOUS -\u003e {\\n                playPrevious()\\n            }\\n        }\\n        return START_STICKY\\n    }\\n// ... existing code ...\\n    private fun playMusic(uri: Uri) {\\n        try {\\n            mediaPlayer?.release()\\n            mediaPlayer \u003d MediaPlayer().apply {\\n                setDataSource(applicationContext, uri)\\n                prepare()\\n                start()\\n                isLooping \u003d false\\n            }\\n            currentUri \u003d uri\\n            startForeground(\\n                1,\\n                buildNotification(isPlaying \u003d true)\\n            )\\n        } catch (e: Exception) {\\n            e.printStackTrace()\\n        }\\n    }\\n\\n    private fun pauseMusic() {\\n        mediaPlayer?.pause()\\n        startForeground(\\n            1,\\n            buildNotification(isPlaying \u003d false)\\n        )\\n    }\\n\\n    private fun stopMusic() {\\n        mediaPlayer?.stop()\\n        mediaPlayer?.release()\\n        stopForeground(true)\\n        stopSelf()\\n    }\\n\\n    private fun resumeMusic() {\\n        mediaPlayer?.let {\\n            if (!it.isPlaying) {\\n                it.start()\\n                startForeground(\\n                    1,\\n                    buildNotification(isPlaying \u003d true)\\n                )\\n            }\\n        }\\n    }\\n\\n    private fun playNext() {\\n        val playlist \u003d PlayerState.playlist.value\\n        val idx \u003d PlayerState.currentIndex.value ?: return\\n        if (playlist.isEmpty()) return\\n        val nextIdx \u003d if (idx + 1 \u003c playlist.size) idx + 1 else 0\\n        PlayerState.setCurrentIndex(nextIdx)\\n        playlist.getOrNull(nextIdx)?.uri?.let { playMusic(it) }\\n    }\\n\\n    private fun playPrevious() {\\n        val playlist \u003d PlayerState.playlist.value\\n        val idx \u003d PlayerState.currentIndex.value ?: return\\n        if (playlist.isEmpty()) return\\n        val prevIdx \u003d if (idx - 1 \u003e\u003d 0) idx - 1 else playlist.lastIndex\\n        PlayerState.setCurrentIndex(prevIdx)\\n        playlist.getOrNull(prevIdx)?.uri?.let { playMusic(it) }\\n    }\\n\\n    private fun buildNotification(isPlaying: Boolean): android.app.Notification {\\n        val channelId \u003d \\\&quot;media_playback\\\&quot;\\n        val notificationManager \u003d getSystemService(android.content.Context.NOTIFICATION_SERVICE) as android.app.NotificationManager\\n        if (android.os.Build.VERSION.SDK_INT \u003e\u003d android.os.Build.VERSION_CODES.O) {\\n            val channel \u003d android.app.NotificationChannel(channelId, \\\&quot;Playback Controls\\\&quot;, android.app.NotificationManager.IMPORTANCE_LOW)\\n            notificationManager.createNotificationChannel(channel)\\n        }\\n        val previousIntent \u003d android.app.PendingIntent.getService(\\n            this, 0, Intent(this, AppService::class.java).setAction(ACTION_PREVIOUS), android.app.PendingIntent.FLAG_UPDATE_CURRENT or getImmutableFlag())\\n        val playPauseIntent \u003d android.app.PendingIntent.getService(\\n            this, 1, Intent(this, AppService::class.java).setAction(if (isPlaying) ACTION_PAUSE else ACTION_RESUME), android.app.PendingIntent.FLAG_UPDATE_CURRENT or getImmutableFlag())\\n        val nextIntent \u003d android.app.PendingIntent.getService(\\n            this, 2, Intent(this, AppService::class.java).setAction(ACTION_NEXT), android.app.PendingIntent.FLAG_UPDATE_CURRENT or getImmutableFlag())\\n        val closeIntent \u003d android.app.PendingIntent.getService(\\n            this, 3, Intent(this, AppService::class.java).setAction(ACTION_CLOSE), android.app.PendingIntent.FLAG_UPDATE_CURRENT or getImmutableFlag())\\n        val song \u003d PlayerState.playlist.value.getOrNull(PlayerState.currentIndex.value ?: 0)\\n        val builder \u003d androidx.core.app.NotificationCompat.Builder(this, channelId)\\n            .setContentTitle(song?.title ?: \\\&quot;No Song\\\&quot;)\\n            .setContentText(song?.artist ?: \\\&quot;\\\&quot;)\\n            .setSmallIcon(android.R.drawable.ic_media_play)\\n            .addAction(android.R.drawable.ic_media_previous, \\\&quot;Previous\\\&quot;, previousIntent)\\n            .addAction(\\n                if (isPlaying) android.R.drawable.ic_media_pause else android.R.drawable.ic_media_play,\\n                if (isPlaying) \\\&quot;Pause\\\&quot; else \\\&quot;Play\\\&quot;,\\n                playPauseIntent)\\n            .addAction(android.R.drawable.ic_media_next, \\\&quot;Next\\\&quot;, nextIntent)\\n            .addAction(android.R.drawable.ic_menu_close_clear_cancel, \\\&quot;Close\\\&quot;, closeIntent)\\n            .setStyle(androidx.media.app.NotificationCompat.MediaStyle()\\n                .setShowActionsInCompactView(0, 1, 2, 3))\\n            .setOnlyAlertOnce(true)\\n            .setOngoing(isPlaying)\\n            .setDeleteIntent(closeIntent)\\n        return builder.build()\\n    }\\n\\n    private fun getImmutableFlag(): Int {\\n        return if (android.os.Build.VERSION.SDK_INT \u003e\u003d android.os.Build.VERSION_CODES.M) android.app.PendingIntent.FLAG_IMMUTABLE else 0\\n    }\\n// ... existing code ...\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;edit_file&quot;,&quot;tool_call_id&quot;:&quot;call_Do6Z48L5F7fQQ7S35YqsZfIP&quot;,&quot;content&quot;:&quot;The apply model made the following changes to the file:\n\n```\n@@ -14,4 +14,6 @@\n         const val ACTION_RESUME \u003d \&quot;action_resume\&quot;\n         const val ACTION_CLOSE \u003d \&quot;action_close\&quot;\n+        const val ACTION_NEXT \u003d \&quot;action_next\&quot;\n+        const val ACTION_PREVIOUS \u003d \&quot;action_previous\&quot;\n         const val EXTRA_URI \u003d \&quot;extra_uri\&quot;\n     }\n@@ -44,4 +46,11 @@\n                 resumeMusic()\n             }\n+            ACTION_NEXT -\u003e {\n+                playNext()\n+            }\n+\n+            ACTION_PREVIOUS -\u003e {\n+                playPrevious()\n+            }\n         }\n         return START_STICKY\n@@ -66,5 +75,5 @@\n             startForeground(\n                 1,\n-\n+                buildNotification(isPlaying \u003d true)\n             )\n         } catch (e: Exception) {\n@@ -77,5 +86,5 @@\n         startForeground(\n             1,\n-\n+            buildNotification(isPlaying \u003d false)\n         )\n     }\n@@ -84,4 +93,5 @@\n         mediaPlayer?.stop()\n         mediaPlayer?.release()\n+        stopForeground(true)\n         stopSelf()\n     }\n@@ -93,9 +103,93 @@\n                 startForeground(\n                     1,\n-\n+                    buildNotification(isPlaying \u003d true)\n                 )\n             }\n         }\n     }\n+    private fun playNext() {\n+        val playlist \u003d PlayerState.playlist.value\n+        val idx \u003d PlayerState.currentIndex.value ?: return\n+        if (playlist.isEmpty()) return\n+        val nextIdx \u003d if (idx + 1 \u003c playlist.size) idx + 1 else 0\n+        PlayerState.setCurrentIndex(nextIdx)\n+        playlist.getOrNull(nextIdx)?.uri?.let { playMusic(it) }\n+    }\n+\n+    private fun playPrevious() {\n+        val playlist \u003d PlayerState.playlist.value\n+        val idx \u003d PlayerState.currentIndex.value ?: return\n+        if (playlist.isEmpty()) return\n+        val prevIdx \u003d if (idx - 1 \u003e\u003d 0) idx - 1 else playlist.lastIndex\n+        PlayerState.setCurrentIndex(prevIdx)\n+        playlist.getOrNull(prevIdx)?.uri?.let { playMusic(it) }\n+    }\n+\n+    private fun buildNotification(isPlaying: Boolean): android.app.Notification {\n+        val channelId \u003d \&quot;media_playback\&quot;\n+        val notificationManager \u003d\n+            getSystemService(android.content.Context.NOTIFICATION_SERVICE) as android.app.NotificationManager\n+        if (android.os.Build.VERSION.SDK_INT \u003e\u003d android.os.Build.VERSION_CODES.O) {\n+            val channel \u003d android.app.NotificationChannel(\n+                channelId,\n+                \&quot;Playback Controls\&quot;,\n+                android.app.NotificationManager.IMPORTANCE_LOW\n+            )\n+            notificationManager.createNotificationChannel(channel)\n+        }\n+        val previousIntent \u003d android.app.PendingIntent.getService(\n+            this,\n+            0,\n+            Intent(this, AppService::class.java).setAction(ACTION_PREVIOUS),\n+            android.app.PendingIntent.FLAG_UPDATE_CURRENT or getImmutableFlag()\n+        )\n+        val playPauseIntent \u003d android.app.PendingIntent.getService(\n+            this,\n+            1,\n+            Intent(\n+                this,\n+                AppService::class.java\n+            ).setAction(if (isPlaying) ACTION_PAUSE else ACTION_RESUME),\n+            android.app.PendingIntent.FLAG_UPDATE_CURRENT or getImmutableFlag()\n+        )\n+        val nextIntent \u003d android.app.PendingIntent.getService(\n+            this,\n+            2,\n+            Intent(this, AppService::class.java).setAction(ACTION_NEXT),\n+            android.app.PendingIntent.FLAG_UPDATE_CURRENT or getImmutableFlag()\n+        )\n+        val closeIntent \u003d android.app.PendingIntent.getService(\n+            this,\n+            3,\n+            Intent(this, AppService::class.java).setAction(ACTION_CLOSE),\n+            android.app.PendingIntent.FLAG_UPDATE_CURRENT or getImmutableFlag()\n+        )\n+        val song \u003d PlayerState.playlist.value.getOrNull(PlayerState.currentIndex.value ?: 0)\n+        val builder \u003d androidx.core.app.NotificationCompat.Builder(this, channelId)\n+            .setContentTitle(song?.title ?: \&quot;No Song\&quot;)\n+            .setContentText(song?.artist ?: \&quot;\&quot;)\n+            .setSmallIcon(android.R.drawable.ic_media_play)\n+            .addAction(android.R.drawable.ic_media_previous, \&quot;Previous\&quot;, previousIntent)\n+            .addAction(\n+                if (isPlaying) android.R.drawable.ic_media_pause else android.R.drawable.ic_media_play,\n+                if (isPlaying) \&quot;Pause\&quot; else \&quot;Play\&quot;,\n+                playPauseIntent\n+            )\n+            .addAction(android.R.drawable.ic_media_next, \&quot;Next\&quot;, nextIntent)\n+            .addAction(android.R.drawable.ic_menu_close_clear_cancel, \&quot;Close\&quot;, closeIntent)\n+            .setStyle(\n+                androidx.media.app.NotificationCompat.MediaStyle()\n+                    .setShowActionsInCompactView(0, 1, 2, 3)\n+            )\n+            .setOnlyAlertOnce(true)\n+            .setOngoing(isPlaying)\n+            .setDeleteIntent(closeIntent)\n+        return builder.build()\n+    }\n+\n+    private fun getImmutableFlag(): Int {\n+        return if (android.os.Build.VERSION.SDK_INT \u003e\u003d android.os.Build.VERSION_CODES.M) android.app.PendingIntent.FLAG_IMMUTABLE else 0\n+    }\n+\n }\n \n```\n\nThe edit introduced the following new linter errors:\n\n```\nLine 181: Unresolved reference: media\n```\n\nPlease fix the linter errors if it is clear how to. Do not make uneducated guesses.&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Tôi thấy lỗi linter sau khi chỉnh sửa là:  \n`Unresolved reference: media`\n\nLỗi này xuất hiện vì đoạn sau:\n```kotlin\nandroidx.media.app.NotificationCompat.MediaStyle()\n```\nChưa import đúng thư viện `androidx.media.app.NotificationCompat`.\n\nTôi sẽ thêm dòng import ở đầu file để fix lỗi này.&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;call_Jtvtv42tKG0TI9wz6Lo2VQ6D&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;edit_file&quot;,&quot;arguments&quot;:&quot;{\&quot;target_file\&quot;:\&quot;app/src/main/java/com/example/hungdm/service/AppService.kt\&quot;,\&quot;instructions\&quot;:\&quot;Thêm import cho androidx.media.app.NotificationCompat để fix lỗi linter.\&quot;,\&quot;code_edit\&quot;:\&quot;// ... existing code ...\\nimport androidx.media.app.NotificationCompat\\n// ... existing code ...\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;edit_file&quot;,&quot;tool_call_id&quot;:&quot;call_Jtvtv42tKG0TI9wz6Lo2VQ6D&quot;,&quot;content&quot;:&quot;The apply model made the following changes to the file:\n\n```\n@@ -1,4 +1,6 @@\n package com.example.hungdm.service\n \n+import androidx.media.app.NotificationCompat\n+\n import android.content.Intent\n import android.media.MediaPlayer\n```\n\nThe edit introduced the following new linter errors:\n\n```\nLine 183: Unresolved reference: media\nLine 3: Unresolved reference: media\n```\n\nPlease fix the linter errors if it is clear how to. Do not make uneducated guesses.&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Tôi đã dùng import như sau:\n```kotlin\nimport androidx.media.app.NotificationCompat\n```\nNhưng tên thật của class là:\n```kotlin\nimport androidx.media.app.NotificationCompat.MediaStyle\n```\nBạn chỉ cần sử dụng:\n```kotlin\nimport androidx.media.app.NotificationCompat\n```\nvà khi gọi nên là:\n```kotlin\nandroidx.media.app.NotificationCompat.MediaStyle()\n```\nhoặc\n```kotlin\nMediaStyle()\n```\nSửa lại như sau:\n- Import: `import androidx.media.app.NotificationCompat`\n- Trong code: `MediaStyle()`\n\nTôi sẽ thay thế `androidx.media.app.NotificationCompat.MediaStyle()` bằng `MediaStyle()` để hợp lệ với import chuẩn.&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;call_ccHSgfSufFuQo05RWTkS3h1B&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;edit_file&quot;,&quot;arguments&quot;:&quot;{\&quot;target_file\&quot;:\&quot;app/src/main/java/com/example/hungdm/service/AppService.kt\&quot;,\&quot;instructions\&quot;:\&quot;Sửa gọi NotificationCompat.MediaStyle() cho phù hợp import.\&quot;,\&quot;code_edit\&quot;:\&quot;// ... existing code ...\\n            .setStyle(\\n-                androidx.media.app.NotificationCompat.MediaStyle()\\n+                MediaStyle()\\n                    .setShowActionsInCompactView(0, 1, 2, 3)\\n            )\\n// ... existing code ...\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;edit_file&quot;,&quot;tool_call_id&quot;:&quot;call_ccHSgfSufFuQo05RWTkS3h1B&quot;,&quot;content&quot;:&quot;The apply model made the following changes to the file:\n\n```\n@@ -181,5 +181,5 @@\n             .addAction(android.R.drawable.ic_menu_close_clear_cancel, \&quot;Close\&quot;, closeIntent)\n             .setStyle(\n-                androidx.media.app.NotificationCompat.MediaStyle()\n+                MediaStyle()\n                     .setShowActionsInCompactView(0, 1, 2, 3)\n             )\n```\n\nThe edit introduced the following new linter errors:\n\n```\nLine 3: Unresolved reference: media\nLine 183: Unresolved reference: MediaStyle\n```\n\nPlease fix the linter errors if it is clear how to. Do not make uneducated guesses.&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Dòng import đúng phải là:\n```kotlin\nimport androidx.media.app.NotificationCompat\n```\nvà khi sử dụng class `MediaStyle`, bạn cần gọi là `NotificationCompat.MediaStyle()` (không cần prefix `androidx.media.app` và không import riêng cho MediaStyle).\n\nTôi sẽ sửa lại:\n```kotlin\nNotificationCompat.MediaStyle()\n```\nở vị trí tạo notification. Đây là cách dùng đúng cho Kotlin và AndroidX.&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;call_R0AZMzPxjP95nvQhHgjsIWwr&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;edit_file&quot;,&quot;arguments&quot;:&quot;{\&quot;target_file\&quot;:\&quot;app/src/main/java/com/example/hungdm/service/AppService.kt\&quot;,\&quot;instructions\&quot;:\&quot;Sử dụng NotificationCompat.MediaStyle() đúng cú pháp với import chuẩn.\&quot;,\&quot;code_edit\&quot;:\&quot;// ... existing code ...\\n            .setStyle(\\n-                MediaStyle()\\n+                NotificationCompat.MediaStyle()\\n                    .setShowActionsInCompactView(0, 1, 2, 3)\\n            )\\n// ... existing code ...\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;edit_file&quot;,&quot;tool_call_id&quot;:&quot;call_R0AZMzPxjP95nvQhHgjsIWwr&quot;,&quot;content&quot;:&quot;The apply model made the following changes to the file:\n\n```\n@@ -181,5 +181,5 @@\n             .addAction(android.R.drawable.ic_menu_close_clear_cancel, \&quot;Close\&quot;, closeIntent)\n             .setStyle(\n-                MediaStyle()\n+                NotificationCompat.MediaStyle()\n                     .setShowActionsInCompactView(0, 1, 2, 3)\n             )\n```\n\nThe edit was successful with no linter errors.&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Đã hoàn thành việc thêm notification kiểu media với các nút Next, Previous, Pause/Resume, Close cho service. Notification sẽ tự động hiển thị khi phát nhạc và xử lý đúng chức năng cho từng nút:\n\n- Next: phát bài tiếp theo.\n- Previous: phát bài trước đó.\n- Pause/Resume: điều khiển phát/tạm dừng.\n- Close: tắt Service.\n\nBạn chỉ cần truyền playlist vào PlayerState để các tính năng next/previous hoạt động. Nếu cần hướng dẫn đồng bộ playlist thực tế vào PlayerState khi chọn bài, hãy báo tôi!&quot;}]}]}" />
        <entry key="7f28c4f5-3898-4256-96e7-f7376bf720ce" value="{&quot;id&quot;:&quot;7f28c4f5-3898-4256-96e7-f7376bf720ce&quot;,&quot;name&quot;:&quot;[TextContent(type\u003dtext, text\u003d\n\u003cadditional_data\u003e\nBelow are some potentially helpful/relevant pieces of information for figuring out to respond\n\u003ccurrent_file\u003e\n```kotlin:app/src/main/java/com/example/hungdm/mvi/MviViewModel.kt, lines\u003dALL(1-657)\npackage com.example.hungdm.mvi\n\nimport android.content.ContentUris\nimport android.content.Context\nimport android.content.Intent\nimport android.media.MediaMetadataRetriever\nimport android.net.Uri\nimport android.provider.MediaStore\nimport android.util.Log\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.example.hungdm.data.db.entity.PlaylistEntity\nimport com.example.hungdm.data.db.entity.PlaylistSongReference\nimport com.example.hungdm.data.mapper.toSong\nimport com.example.hungdm.domain.model.Playlist\nimport com.example.hungdm.domain.model.Song\nimport com.example.hungdm.domain.repo.PlaylistRepository\nimport com.example.hungdm.domain.repo.UserRepository\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.flow.MutableSharedFlow\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.SharedFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.asSharedFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.withContext\nimport com.example.hungdm.data.mapper.toSongEntity\nimport com.example.hungdm.data.mapper.toUserEntity\nimport com.example.hungdm.data.mapper.toUserInfo\nimport com.example.hungdm.data.remote.musicApi.ApiMusicClient\nimport com.example.hungdm.data.remote.musicApi.dto.TopAlbums\nimport com.example.hungdm.data.remote.musicApi.dto.TopArtists\nimport com.example.hungdm.data.remote.musicApi.dto.TopTracks\nimport com.example.hungdm.data.remote.songApi.ApiSongClient\nimport com.example.hungdm.domain.model.UserInfo\nimport com.example.hungdm.service.AppService\nimport com.example.hungdm.utils.AppUtils\nimport kotlinx.coroutines.flow.update\nimport java.io.BufferedInputStream\nimport java.io.File\nimport java.io.FileOutputStream\nimport java.io.IOException\nimport java.net.HttpURLConnection\nimport java.net.URL\nimport java.net.UnknownHostException\n\nclass MviViewModel(\n    private val userRepository: UserRepository,\n    private val playlistRepository: PlaylistRepository\n) : ViewModel() {\n\n    private val _state \u003d MutableStateFlow(MviState())\n    val state: StateFlow\u003cMviState\u003e \u003d _state.asStateFlow()\n    private val _event \u003d MutableSharedFlow\u003cMviEvent\u003e()\n    val event: SharedFlow\u003cMviEvent\u003e \u003d _event.asSharedFlow()\n\n    init {\n        viewModelScope.launch {\n            AppService.playerPlaylist.collect { playerPlaylist -\u003e\n                _state.update { it.copy(playerPlaylist \u003d playerPlaylist) }\n            }\n        }\n        viewModelScope.launch {\n            AppService.playerListSong.collect { playerListSong -\u003e\n                _state.update { it.copy(playerListSong \u003d playerListSong) }\n            }\n        }\n        viewModelScope.launch {\n            AppService.playerSong.collect { playerSong -\u003e\n                _state.update { it.copy(playerSong \u003d playerSong) }\n            }\n        }\n        viewModelScope.launch {\n            AppService.playerSongIndex.collect { playerSongIndex -\u003e\n                _state.update { it.copy(playerSongIndex \u003d playerSongIndex) }\n            }\n        }\n        viewModelScope.launch {\n            AppService.playerTime.collect { playerTime -\u003e\n                _state.update { it.copy(playerTime \u003d playerTime) }\n            }\n        }\n        viewModelScope.launch {\n            AppService.isPlay.collect { isPlay -\u003e\n                _state.update { it.copy(isPlay \u003d isPlay) }\n            }\n        }\n        viewModelScope.launch {\n            AppService.isShuffle.collect { isShuffle -\u003e\n                _state.update { it.copy(isShuffle \u003d isShuffle) }\n            }\n        }\n        viewModelScope.launch {\n            AppService.isRepeat.collect { isRepeat -\u003e\n                _state.update { it.copy(isRepeat \u003d isRepeat) }\n            }\n        }\n    }\n\n    fun processIntent(intent: MviIntent) {\n        viewModelScope.launch {\n            when (intent) {\n                is MviIntent.GetUser -\u003e {\n                    getUser(intent.userId)\n                }\n\n                is MviIntent.OnClickSignup -\u003e {\n                    sendEvent(MviEvent.GotoSignup)\n                }\n\n                is MviIntent.CheckLogin -\u003e {\n                    checkLogin(intent.userInfo, intent.context)\n                }\n\n                is MviIntent.CheckSignup -\u003e {\n                    checkSignup(intent.userInfo)\n                }\n\n                is MviIntent.OnClickProfile -\u003e {\n                    sendEvent(MviEvent.GotoProfile)\n                }\n\n                is MviIntent.EditProfile -\u003e {\n                    editProfile(intent.userInfo)\n                }\n\n                is MviIntent.OnLogout -\u003e {\n                    logout(intent.context)\n                }\n\n                is MviIntent.OnClickSetting -\u003e {\n                    sendEvent(MviEvent.GotoSettings)\n                }\n\n                is MviIntent.ChangeTheme -\u003e {\n                    _state.value \u003d _state.value.copy(darkTheme \u003d !_state.value.darkTheme)\n                }\n\n                is MviIntent.LoadMusicData -\u003e {\n                    _state.value \u003d _state.value.copy(\n                        topAlbums \u003d getTopAlbums(),\n                        topTracks \u003d getTopTracks(),\n                        topArtists \u003d getTopArtists()\n                    )\n                }\n\n                is MviIntent.OnClickSeeAllTopAlbums -\u003e {\n                    sendEvent(MviEvent.GotoTopAlbums)\n                }\n\n                is MviIntent.OnClickSeeAllTopTracks -\u003e {\n                    sendEvent(MviEvent.GotoTopTracks)\n                }\n\n                is MviIntent.OnClickSeeAllTopArtists -\u003e {\n                    sendEvent(MviEvent.GotoTopArtists)\n                }\n\n                is MviIntent.LoadPlaylistsOfUser -\u003e {\n                    _state.value \u003d _state.value.copy(playlists \u003d loadPlaylistOfUser())\n                }\n\n                is MviIntent.LoadSongLocal -\u003e {\n                    val songs \u003d withContext(Dispatchers.IO) {\n                        getSongExternal(intent.context)\n                    }\n                    _state.value \u003d _state.value.copy(listSongLocal \u003d songs)\n                }\n\n                is MviIntent.LoadSongRemote -\u003e {\n                    loadSongRemote(intent.context)\n                }\n\n                is MviIntent.CreatePlaylist -\u003e {\n                    createPlaylist(intent.title)\n                }\n\n                is MviIntent.RenamePlaylist -\u003e {\n                    playlistRepository.renamePlaylist(intent.playlist.id, intent.title)\n                    _state.value \u003d _state.value.copy(playlists \u003d loadPlaylistOfUser())\n                }\n\n                is MviIntent.RemovePlaylist -\u003e {\n                    removePlaylist(intent.context, intent.playlist)\n                }\n\n                is MviIntent.AddSongToPlaylist -\u003e {\n                    addSongToPlaylist(intent.context, intent.song, intent.playlist)\n                }\n\n                is MviIntent.RemoveSongInPlaylist -\u003e {\n                    removeSongInPlaylist(intent.context, intent.song, intent.playlist)\n                }\n\n                is MviIntent.OnClickPlaylistDetail -\u003e {\n                    sendEvent(MviEvent.GotoPlaylistDetail(intent.playlistId))\n                }\n\n                is MviIntent.OnClickPlayer -\u003e {\n                    playSong(intent.song,intent.playerListSong,intent.playerPlaylist,intent.context)\n                }\n\n                is MviIntent.OnChangeSongPlayState -\u003e {\n                    onPauseResume(intent.context)\n                }\n\n                is MviIntent.OnClickNextSong -\u003e {\n                    val tmpIntent \u003d Intent(intent.context, AppService::class.java).apply {\n                        action \u003d AppService.ACTION_NEXT\n                    }\n                    intent.context.startForegroundService(tmpIntent)\n                }\n\n                is MviIntent.OnClickPreviousSong -\u003e {\n                    val tmpIntent \u003d Intent(intent.context, AppService::class.java).apply {\n                        action \u003d AppService.ACTION_PREVIOUS\n                    }\n                    intent.context.startForegroundService(tmpIntent)\n                }\n\n                is MviIntent.OnClickShuffle -\u003e {\n                    val tmpIntent \u003d Intent(intent.context, AppService::class.java).apply {\n                        action \u003d AppService.ACTION_SHUFFLE\n                    }\n                    intent.context.startForegroundService(tmpIntent)\n                }\n\n                is MviIntent.OnClickRepeat -\u003e {\n                    val tmpIntent \u003d Intent(intent.context, AppService::class.java).apply {\n                        action \u003d AppService.ACTION_REPEAT\n                    }\n                    intent.context.startForegroundService(tmpIntent)\n                }\n\n                is MviIntent.OnClickClosePlayer -\u003e {\n                    val tmpIntent \u003d Intent(intent.context, AppService::class.java).apply {\n                        action \u003d AppService.ACTION_CLOSE\n                    }\n                    intent.context.startForegroundService(tmpIntent)\n                }\n            }\n        }\n    }\n\n    private fun sendEvent(event: MviEvent) {\n        viewModelScope.launch {\n            _event.emit(event)\n        }\n    }\n\n    private suspend fun getUser(userId: Long) {\n        val user \u003d withContext(Dispatchers.IO) {\n            userRepository.getUserById(userId)\n        }\n        _state.value \u003d _state.value.copy(userInfo \u003d user!!.toUserInfo())\n    }\n\n    private suspend fun checkLogin(userInfo: UserInfo, context: Context) {\n        val user \u003d withContext(Dispatchers.IO) {\n            userRepository.login(userInfo.username, userInfo.password)\n        }\n        if (user !\u003d null) {\n            _state.value \u003d _state.value.copy(userInfo \u003d user.toUserInfo())\n            AppUtils.saveUser(context, user.userId)\n            sendEvent(MviEvent.GotoHome)\n        } else {\n            sendEvent(MviEvent.ShowToast(\&quot;Login failed\&quot;))\n        }\n    }\n\n    private suspend fun checkSignup(userInfo: UserInfo) {\n        try {\n            val result \u003d withContext(Dispatchers.IO) {\n                userRepository.signup(\n                    username \u003d userInfo.username,\n                    password \u003d userInfo.password,\n                    email \u003d userInfo.email\n                )\n            }\n            if (result \u003e 0) {\n                sendEvent(MviEvent.GotoLogin)\n            } else {\n                sendEvent(MviEvent.ShowToast(\&quot;Username already exists\&quot;))\n            }\n        } catch (e: Exception) {\n            sendEvent(MviEvent.ShowToast(\&quot;Signup failed ${e.message}\&quot;))\n        }\n    }\n\n    private suspend fun editProfile(userInfo: UserInfo) {\n        withContext(Dispatchers.IO) {\n            userRepository.updateUser(userInfo.toUserEntity())\n        }\n        _state.value \u003d _state.value.copy(userInfo \u003d userInfo)\n    }\n\n    private fun logout(context: Context) {\n        AppUtils.clear(context)\n        AppUtils.setAppLanguage(\&quot;en\&quot;, context)\n        val tmpIntent \u003d Intent(context, AppService::class.java).apply {\n            action \u003d AppService.ACTION_CLOSE\n        }\n        context.startService(tmpIntent)\n        _state.value \u003d MviState()\n        sendEvent(MviEvent.GotoLogin)\n    }\n\n    private suspend fun loadSongRemote(context: Context){\n        val dir \u003d File(context.filesDir, _state.value.userInfo.username)\n        if (!dir.exists()) {\n            val songApi \u003d getSongRemote()\n            //delay(1000) // neu k co delay thi songApi \u003d null, vi interface ApiService dunng Call\u003cList\u003cSongRemote\u003e\u003e\n            val songInternal \u003d mutableListOf\u003cSong\u003e()\n            withContext(Dispatchers.IO) {\n                for (i in songApi) {\n                    songInternal.add(\n                        downloadSongToInternalStorage(\n                            context, i.path!!, _state.value.userInfo.username, i.title + \&quot;.mp3\&quot;\n                        )!!\n                    )\n                }\n            }\n            _state.value \u003d _state.value.copy(listSongRemote \u003d songInternal)\n        } else {\n            val songs \u003d\n                getALlSongInternal(context, _state.value.userInfo.username)\n            _state.value \u003d _state.value.copy(listSongRemote \u003d songs)\n        }\n    }\n\n    private suspend fun createPlaylist(title: String){\n        val playlistEntity \u003d PlaylistEntity(\n            title \u003d title,\n            userId \u003d _state.value.userInfo.id\n        )\n        playlistRepository.createPlaylist(playlistEntity)\n        _state.value \u003d _state.value.copy(playlists \u003d loadPlaylistOfUser())\n    }\n\n    private suspend fun loadPlaylistOfUser(): List\u003cPlaylist\u003e {\n        val playlists \u003d mutableListOf\u003cPlaylist\u003e()\n        withContext(Dispatchers.IO) {\n            val playlistWithSongsList \u003d\n                playlistRepository.getPlaylistsWithSongsOfUser(_state.value.userInfo.id)\n            playlistWithSongsList.map {\n                val songs \u003d it.songs.map { songEntity -\u003e\n                    Song(\n                        id \u003d songEntity.songId,\n                        title \u003d songEntity.title,\n                        artist \u003d songEntity.artist,\n                        duration \u003d songEntity.duration,\n                        uri \u003d songEntity.uri,\n                        img \u003d songEntity.img\n                    )\n                }\n                playlists.add(\n                    Playlist(\n                        id \u003d it.playlist.playlistId,\n                        title \u003d it.playlist.title,\n                        listSong \u003d songs.toMutableList()\n                    )\n                )\n            }\n        }\n        return playlists\n    }\n\n    private suspend fun getSongExternal(context: Context): MutableList\u003cSong\u003e {\n        val songs \u003d mutableListOf\u003cSong\u003e()\n        withContext(Dispatchers.IO) {\n            val uri \u003d MediaStore.Audio.Media.EXTERNAL_CONTENT_URI\n            val projection \u003d arrayOf(\n                MediaStore.Audio.Media._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.DURATION,\n                MediaStore.Audio.Albums.ALBUM_ID\n            )\n\n            val selection \u003d \&quot;${MediaStore.Audio.Media.IS_MUSIC} !\u003d 0\&quot;\n\n            val cursor \u003d context.contentResolver.query(\n                uri, projection, selection, null, null\n            )\n            cursor?.use {\n                val idColumn \u003d it.getColumnIndexOrThrow(MediaStore.Audio.Media._ID)\n                val titleColumn \u003d it.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE)\n                val artistColumn \u003d it.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST)\n                val durationColumn \u003d it.getColumnIndexOrThrow(MediaStore.Audio.Media.DURATION)\n                val albumIdColumn \u003d it.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM_ID)\n\n                while (it.moveToNext()) {\n                    val id \u003d it.getLong(idColumn)\n                    val title \u003d it.getString(titleColumn)\n                    val artist \u003d it.getString(artistColumn)\n                    val duration \u003d it.getLong(durationColumn)\n                    val albumId \u003d it.getLong(albumIdColumn)\n                    val songUri \u003d\n                        ContentUris.withAppendedId(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, id)\n                    val img \u003d AppUtils.getAlbumArt(context, albumId)\n                    songs.add(Song(id, title, artist, duration, songUri, img))\n                }\n            }\n        }\n        return songs\n    }\n\n    private suspend fun getALlSongInternal(\n        context: Context,\n        folderName: String\n    ): MutableList\u003cSong\u003e {\n        val songs \u003d mutableListOf\u003cSong\u003e()\n        val dir \u003d File(context.filesDir, folderName)\n        val mp3 \u003d dir.listFiles() ?: return mutableListOf()\n\n        withContext(Dispatchers.IO) {\n            val retriever \u003d MediaMetadataRetriever()\n            for (i in mp3) {\n                try {\n                    retriever.setDataSource(i.absolutePath)\n                    val title \u003d retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_TITLE)\n                        ?: i.nameWithoutExtension\n                    val artist \u003d\n                        retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ARTIST)\n                            ?: \&quot;Unknown Artist\&quot;\n                    val duration \u003d\n                        retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION)\n                            ?.toLongOrNull() ?: 0L\n                    val path \u003d i.absolutePath\n                    val img \u003d retriever.embeddedPicture\n                    songs.add(\n                        Song(\n                            title \u003d title,\n                            artist \u003d artist,\n                            duration \u003d duration,\n                            uri \u003d Uri.fromFile(i),\n                            img \u003d img,\n                            path \u003d path\n                        )\n                    )\n                } catch (e: Exception) {\n                    Log.d(\&quot;getSongInternal\&quot;, e.toString())\n                }\n            }\n        }\n        return songs\n    }\n\n    private suspend fun getSongRemote(): MutableList\u003cSong\u003e \u003d withContext(Dispatchers.IO) {\n        return@withContext try {\n            ApiSongClient.build().getSongRemote().map { it.toSong() }.toMutableList()\n        } catch (e: UnknownHostException) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Khong co mang: ${e.message}\&quot;)\n            mutableListOf()\n        } catch (e: IOException) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Loi IO: ${e.message}\&quot;)\n            mutableListOf()\n        } catch (e: Exception) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Loi khac: ${e.message}\&quot;)\n            mutableListOf()\n        }\n    }\n\n    private suspend fun getTopAlbums(): TopAlbums? \u003d withContext(Dispatchers.IO) {\n        return@withContext try {\n            ApiMusicClient.build().getTopAlbums().topalbums\n        } catch (e: UnknownHostException) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Khong co mang: ${e.message}\&quot;)\n            null\n        } catch (e: IOException) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Loi IO: ${e.message}\&quot;)\n            null\n        } catch (e: Exception) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Loi khac: ${e.message}\&quot;)\n            null\n        }\n    }\n\n    private suspend fun getTopTracks(): TopTracks? \u003d withContext(Dispatchers.IO) {\n        return@withContext try {\n            ApiMusicClient.build().getTopTracks().toptracks\n        } catch (e: UnknownHostException) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Khong co mang: ${e.message}\&quot;)\n            null\n        } catch (e: IOException) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Loi IO: ${e.message}\&quot;)\n            null\n        } catch (e: Exception) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Loi khac: ${e.message}\&quot;)\n            null\n        }\n    }\n\n    private suspend fun getTopArtists(): TopArtists? \u003d withContext(Dispatchers.IO) {\n        return@withContext try {\n            ApiMusicClient.build().getTopArtists().topArtists\n        } catch (e: UnknownHostException) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Khong co mang: ${e.message}\&quot;)\n            null\n        } catch (e: IOException) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Loi IO: ${e.message}\&quot;)\n            null\n        } catch (e: Exception) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Loi khac: ${e.message}\&quot;)\n            null\n        }\n    }\n\n    private suspend fun removeSongInPlaylist(context: Context, song: Song, playlist: Playlist) {\n        withContext(Dispatchers.IO) {\n            playlistRepository.removeSongInPlaylist(song.id, playlist.id)\n            _state.value \u003d _state.value.copy(playlists \u003d loadPlaylistOfUser())\n            if (_state.value.playerPlaylist?.id \u003d\u003d playlist.id) {\n                val newPlaylist \u003d _state.value.playlists.find {\n                    it.id \u003d\u003d playlist.id\n                }\n                if (song.id \u003d\u003d _state.value.playerSong?.id) {\n                    Log.d(\&quot;HungDM\&quot;, \&quot;chay not bai day di\&quot;)\n                }\n                val tmpIntent \u003d Intent(context, AppService::class.java).apply {\n                    action \u003d AppService.ACTION_UPDATE\n                    putExtra(AppService.EXTRA_PLAYLIST, newPlaylist)\n                }\n                context.startForegroundService(tmpIntent)\n            }\n        }\n    }\n\n    private suspend fun addSongToPlaylist(context: Context, song: Song, playlist: Playlist) {\n        withContext(Dispatchers.IO) {\n            val id \u003d playlistRepository.addSong(song.toSongEntity())\n            playlistRepository.addSongToPlaylist(\n                PlaylistSongReference(playlist.id, id)\n            )\n            _state.value \u003d _state.value.copy(playlists \u003d loadPlaylistOfUser())\n            if (_state.value.playerPlaylist?.id \u003d\u003d playlist.id) {\n                val newPlaylist \u003d _state.value.playlists.find {\n                    it.id \u003d\u003d playlist.id\n                }\n                val tmpIntent \u003d Intent(context, AppService::class.java).apply {\n                    action \u003d AppService.ACTION_UPDATE\n                    putExtra(AppService.EXTRA_PLAYLIST, newPlaylist)\n                }\n                context.startForegroundService(tmpIntent)\n            }\n        }\n    }\n\n    private suspend fun removePlaylist(context: Context, playlist: Playlist) {\n        withContext(Dispatchers.IO) {\n            playlistRepository.removePlaylist(playlist.id)\n            playlistRepository.removeAllSongInPlaylist(playlist.id)\n            _state.value \u003d _state.value.copy(playlists \u003d loadPlaylistOfUser())\n            if (_state.value.playerPlaylist?.id \u003d\u003d playlist.id) {\n                val tmpIntent \u003d Intent(context, AppService::class.java).apply {\n                    action \u003d AppService.ACTION_CLOSE\n                }\n                context.startForegroundService(tmpIntent)\n            }\n        }\n    }\n\n    private fun playSong(song: Song, playerListSong: List\u003cSong\u003e?, playerPlaylist: Playlist?, context: Context){\n        val playerSongIndex \u003d playerListSong?.indexOf(song) ?: playerPlaylist!!.listSong.indexOf(song)\n        val tmpIntent \u003d Intent(context, AppService::class.java).apply {\n            action \u003d AppService.ACTION_PLAY\n            putExtra(AppService.EXTRA_PLAYLIST, playerPlaylist)\n            putExtra(\n                AppService.EXTRA_LIST_SONG, ArrayList(playerListSong ?: emptyList())\n            )\n            putExtra(AppService.EXTRA_SONG, song)\n            putExtra(AppService.EXTRA_INDEX, playerSongIndex)\n        }\n        context.startForegroundService(tmpIntent)\n    }\n\n    private fun onPauseResume(context: Context){\n        if (_state.value.isPlay) {\n            val tmpIntent \u003d Intent(context, AppService::class.java).apply {\n                action \u003d AppService.ACTION_PAUSE\n            }\n            context.startForegroundService(tmpIntent)\n        } else {\n            val tmpIntent \u003d Intent(context, AppService::class.java).apply {\n                action \u003d AppService.ACTION_RESUME\n            }\n            context.startForegroundService(tmpIntent)\n        }\n    }\n\n    private suspend fun downloadSongToInternalStorage(\n        context: Context,\n        fileUrl: String,\n        folderName: String,\n        fileName: String\n    ): Song? {\n        val dir \u003d File(context.filesDir, folderName)\n        if (!dir.exists()) dir.mkdir()\n        val file \u003d File(dir, fileName)\n        if (file.exists()) return null\n\n        return try {\n            var song: Song?\n            withContext(Dispatchers.IO) {\n                val url \u003d URL(fileUrl)\n                val connection \u003d withContext(Dispatchers.IO) {\n                    url.openConnection()\n                } as HttpURLConnection\n                connection.connectTimeout \u003d 5000\n                connection.readTimeout \u003d 5000\n                connection.requestMethod \u003d \&quot;GET\&quot;\n                connection.doInput \u003d true\n                connection.connect()\n\n                if (connection.responseCode !\u003d HttpURLConnection.HTTP_OK) {\n                    throw IOException(\&quot;HTTP error code: ${connection.responseCode}\&quot;)\n                }\n\n                val inputStream \u003d BufferedInputStream(connection.inputStream)\n                val outputStream \u003d FileOutputStream(file)\n\n                inputStream.use { input -\u003e\n                    outputStream.use { output -\u003e\n                        input.copyTo(output)\n                    }\n                }\n\n                val retriever \u003d MediaMetadataRetriever()\n                retriever.setDataSource(file.absolutePath)\n\n                val title \u003d retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_TITLE)\n                    ?: file.nameWithoutExtension\n                val artist \u003d retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ARTIST)\n                    ?: \&quot;Unknown Artist\&quot;\n                val duration \u003d\n                    retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION)\n                        ?.toLongOrNull() ?: 0L\n                val uri \u003d Uri.fromFile(file)\n                val img \u003d retriever.embeddedPicture\n                val path \u003d file.absolutePath\n                song \u003d Song(\n                    title \u003d title,\n                    artist \u003d artist,\n                    duration \u003d duration,\n                    uri \u003d uri,\n                    img \u003d img,\n                    path \u003d path\n                )\n            }\n            song\n        } catch (e: Exception) {\n            e.printStackTrace()\n            null\n        }\n    }\n}\n```\n\u003c/current_file\u003e\n\n\n\u003cattached_files\u003e\n\u003cfile_contents\u003e\n```kotlin:app/src/main/java/com/example/hungdm/service/AppService.kt, lines\u003dALL(1-262)\npackage com.example.hungdm.service\n\nimport android.content.Intent\nimport android.media.MediaPlayer\nimport android.os.IBinder\nimport android.util.Log\nimport androidx.lifecycle.LifecycleService\nimport androidx.lifecycle.lifecycleScope\nimport com.example.hungdm.domain.model.Playlist\nimport com.example.hungdm.domain.model.Song\nimport kotlinx.coroutines.Job\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.isActive\nimport kotlinx.coroutines.launch\nimport kotlin.random.Random\nimport kotlin.random.nextInt\n\nclass AppService : LifecycleService() {\n\n    companion object {\n        const val ACTION_PLAY \u003d \&quot;ACTION_PLAY\&quot;\n        const val ACTION_PAUSE \u003d \&quot;ACTION_PAUSE\&quot;\n        const val ACTION_RESUME \u003d \&quot;ACTION_RESUME\&quot;\n        const val ACTION_CLOSE \u003d \&quot;ACTION_CLOSE\&quot;\n        const val ACTION_NEXT \u003d \&quot;ACTION_NEXT\&quot;\n        const val ACTION_PREVIOUS \u003d \&quot;ACTION_PREVIOUS\&quot;\n        const val ACTION_UPDATE \u003d \&quot;ACTION_UPDATE\&quot;\n        const val ACTION_SHUFFLE \u003d \&quot;ACTION_SHUFFLE\&quot;\n        const val ACTION_REPEAT \u003d \&quot;ACTION_REPEAT\&quot;\n        const val EXTRA_PLAYLIST \u003d \&quot;EXTRA_PLAYLIST\&quot;\n        const val EXTRA_LIST_SONG \u003d \&quot;EXTRA_LIST_SONG\&quot;\n        const val EXTRA_INDEX \u003d \&quot;EXTRA_INDEX\&quot;\n        const val EXTRA_SONG \u003d \&quot;EXTRA_SONG\&quot;\n\n        val playerPlaylist: MutableStateFlow\u003cPlaylist?\u003e \u003d MutableStateFlow(null)\n        val playerListSong: MutableStateFlow\u003cList\u003cSong\u003e?\u003e \u003d MutableStateFlow(null)\n        val playerSongIndex: MutableStateFlow\u003cInt?\u003e \u003d MutableStateFlow(null)\n        val playerSong: MutableStateFlow\u003cSong?\u003e \u003d MutableStateFlow(null)\n        val playerTime: MutableStateFlow\u003cLong\u003e \u003d MutableStateFlow(0L)\n        val isPlay: MutableStateFlow\u003cBoolean\u003e \u003d MutableStateFlow(false)\n        val isShuffle: MutableStateFlow\u003cBoolean\u003e \u003d MutableStateFlow(false)\n        val isRepeat: MutableStateFlow\u003cBoolean\u003e \u003d MutableStateFlow(false)\n    }\n\n    private var mediaPlayer: MediaPlayer? \u003d null\n    private var notificationHelper: NotificationHelper? \u003d null\n    private var timeJob: Job? \u003d null\n\n    override fun onCreate() {\n        super.onCreate()\n        notificationHelper \u003d NotificationHelper(this)\n    }\n\n    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {\n        super.onStartCommand(intent, flags, startId)\n        when (intent?.action) {\n            ACTION_PLAY -\u003e {\n                playerPlaylist.value \u003d intent.getParcelableExtra\u003cPlaylist\u003e(EXTRA_PLAYLIST)\n                playerListSong.value \u003d intent.getParcelableArrayListExtra\u003cSong\u003e(EXTRA_LIST_SONG)\n                playerSongIndex.value \u003d intent.getIntExtra(EXTRA_INDEX,0)\n                playerSong.value \u003d intent.getParcelableExtra\u003cSong\u003e(EXTRA_SONG)\n                playerTime.value \u003d 0L\n                isPlay.value \u003d true\n                playSong()\n            }\n            ACTION_PAUSE -\u003e {\n                isPlay.value \u003d false\n                pauseSong()\n            }\n            ACTION_CLOSE -\u003e {\n                playerPlaylist.value \u003d null\n                playerListSong.value \u003d null\n                playerSongIndex.value \u003d null\n                playerSong.value \u003d null\n                playerTime.value \u003d 0L\n                isPlay.value \u003d false\n                closeSong()\n            }\n            ACTION_RESUME -\u003e {\n                isPlay.value \u003d true\n                resumeSong()\n            }\n            ACTION_NEXT -\u003e {\n                if(isShuffle.value){\n                    shuffleSong()\n                } else if(isRepeat.value){\n                    repeatSong()\n                } else nextSong()\n\n            }\n            ACTION_PREVIOUS -\u003e {\n                if(isShuffle.value){\n                    shuffleSong()\n                } else if(isRepeat.value){\n                    repeatSong()\n                } else previousSong()\n            }\n            ACTION_SHUFFLE -\u003e {\n                isShuffle.value \u003d !isShuffle.value\n                isRepeat.value \u003d false\n            }\n            ACTION_REPEAT -\u003e {\n                isRepeat.value \u003d !isRepeat.value\n                isShuffle.value \u003d false\n            }\n            ACTION_UPDATE -\u003e {\n                playerPlaylist.value \u003d intent.getParcelableExtra\u003cPlaylist\u003e(EXTRA_PLAYLIST)\n            }\n        }\n        return START_STICKY\n    }\n\n    override fun onDestroy() {\n        mediaPlayer?.release()\n        mediaPlayer \u003d null\n        stopForeground(true)\n        super.onDestroy()\n    }\n\n    private fun playSong() {\n        try {\n            mediaPlayer?.release()\n            mediaPlayer \u003d MediaPlayer().apply {\n                setDataSource(applicationContext, playerSong.value?.uri!!)\n                prepare()\n                start()\n                isLooping \u003d false\n                setOnCompletionListener {\n                    if(isShuffle.value){\n                        shuffleSong()\n                    } else if(isRepeat.value){\n                        repeatSong()\n                    } else nextSong()\n                }\n            }\n            isPlay.value \u003d true\n            startUpdatingTime()\n            startForeground(\n                1,\n                notificationHelper?.createNotification(playerSong.value?.title!!, isPlay.value)\n            )\n        } catch (e: Exception) {\n            e.printStackTrace()\n        }\n    }\n\n    private fun pauseSong() {\n        timeJob?.cancel()\n        mediaPlayer?.pause()\n        startForeground(\n            1,\n            notificationHelper?.createNotification(playerSong.value?.title!!, isPlay.value)\n        )\n    }\n\n    private fun closeSong() {\n        mediaPlayer?.stop()\n        mediaPlayer?.release()\n        mediaPlayer \u003d null\n        notificationHelper \u003d null\n        stopSelf()\n    }\n\n    private fun resumeSong() {\n        mediaPlayer?.let {\n            if (!it.isPlaying) {\n                it.start()\n                startUpdatingTime()\n                startForeground(\n                    1,\n                    notificationHelper?.createNotification(playerSong.value?.title!!, isPlay.value)\n                )\n            }\n        }\n    }\n\n    private fun nextSong() {\n        if(playerPlaylist.value\u003d\u003dnull){\n            val nextIndex \u003d if (playerSongIndex.value!! \u003e\u003d playerListSong.value!!.size - 1) 0 else playerSongIndex.value!! + 1\n\n            playerSongIndex.value \u003d nextIndex\n            playerSong.value \u003d playerListSong.value!![nextIndex]\n            playerTime.value \u003d 0L\n        } else {\n            val nextIndex \u003d if (playerSongIndex.value!! \u003e\u003d playerPlaylist.value!!.listSong.size - 1) 0 else playerSongIndex.value!! + 1\n\n            playerSongIndex.value \u003d nextIndex\n            playerSong.value \u003d playerPlaylist.value!!.listSong[nextIndex]\n            playerTime.value \u003d 0L\n        }\n\n        playSong()\n    }\n\n    private fun previousSong(){\n        if(playerPlaylist.value\u003d\u003dnull){\n            val preIndex \u003d if (playerSongIndex.value!! \u003c\u003d 0) playerListSong.value!!.size - 1 else playerSongIndex.value!! - 1\n\n            playerSongIndex.value \u003d preIndex\n            playerSong.value \u003d playerListSong.value!![preIndex]\n            playerTime.value \u003d 0L\n        } else {\n            val preIndex \u003d if (playerSongIndex.value!! \u003c\u003d 0) playerPlaylist.value!!.listSong.size - 1 else playerSongIndex.value!! - 1\n\n            playerSongIndex.value \u003d preIndex\n            playerSong.value \u003d playerPlaylist.value!!.listSong[preIndex]\n            playerTime.value \u003d 0L\n        }\n\n        playSong()\n    }\n\n    private fun shuffleSong() {\n        if(playerPlaylist.value\u003d\u003dnull){\n            val nextIndex \u003d Random.nextInt(0, playerListSong.value!!.size)\n\n            playerSongIndex.value \u003d nextIndex\n            playerSong.value \u003d playerListSong.value!![nextIndex]\n            playerTime.value \u003d 0L\n        } else {\n            val nextIndex \u003d Random.nextInt(0, playerPlaylist.value!!.listSong.size)\n\n            playerSongIndex.value \u003d nextIndex\n            playerSong.value \u003d playerPlaylist.value!!.listSong[nextIndex]\n            playerTime.value \u003d 0L\n        }\n\n        playSong()\n    }\n\n    private fun repeatSong() {\n        if(playerPlaylist.value\u003d\u003dnull){\n            val nextIndex \u003d playerSongIndex.value!!\n\n            playerSongIndex.value \u003d nextIndex\n            playerSong.value \u003d playerListSong.value!![nextIndex]\n            playerTime.value \u003d 0L\n        } else {\n            val nextIndex \u003d playerSongIndex.value!!\n\n            playerSongIndex.value \u003d nextIndex\n            playerSong.value \u003d playerPlaylist.value!!.listSong[nextIndex]\n            playerTime.value \u003d 0L\n        }\n\n        playSong()\n    }\n\n\n    private fun startUpdatingTime() {\n        timeJob?.cancel()\n        timeJob \u003d lifecycleScope.launch {\n            while (isActive) {\n                val time \u003d mediaPlayer?.currentPosition?.toLong() ?: 0L\n                playerTime.value \u003d time\n                delay(100)\n            }\n        }\n    }\n}\n\n```\n\u003c/file_contents\u003e\n\n\u003c/attached_files\u003e\n\u003c/additional_data\u003e\n\u003cuser_query\u003e\nbạn đọc code của tôi và có thấy vấn đề nào không\n\u003c/user_query\u003e)]&quot;,&quot;timestamp&quot;:1755088526062,&quot;messages&quot;:[{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;\n\u003cadditional_data\u003e\nBelow are some potentially helpful/relevant pieces of information for figuring out to respond\n\u003ccurrent_file\u003e\n```kotlin:app/src/main/java/com/example/hungdm/mvi/MviViewModel.kt, lines\u003dALL(1-657)\npackage com.example.hungdm.mvi\n\nimport android.content.ContentUris\nimport android.content.Context\nimport android.content.Intent\nimport android.media.MediaMetadataRetriever\nimport android.net.Uri\nimport android.provider.MediaStore\nimport android.util.Log\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.example.hungdm.data.db.entity.PlaylistEntity\nimport com.example.hungdm.data.db.entity.PlaylistSongReference\nimport com.example.hungdm.data.mapper.toSong\nimport com.example.hungdm.domain.model.Playlist\nimport com.example.hungdm.domain.model.Song\nimport com.example.hungdm.domain.repo.PlaylistRepository\nimport com.example.hungdm.domain.repo.UserRepository\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.flow.MutableSharedFlow\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.SharedFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.asSharedFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.withContext\nimport com.example.hungdm.data.mapper.toSongEntity\nimport com.example.hungdm.data.mapper.toUserEntity\nimport com.example.hungdm.data.mapper.toUserInfo\nimport com.example.hungdm.data.remote.musicApi.ApiMusicClient\nimport com.example.hungdm.data.remote.musicApi.dto.TopAlbums\nimport com.example.hungdm.data.remote.musicApi.dto.TopArtists\nimport com.example.hungdm.data.remote.musicApi.dto.TopTracks\nimport com.example.hungdm.data.remote.songApi.ApiSongClient\nimport com.example.hungdm.domain.model.UserInfo\nimport com.example.hungdm.service.AppService\nimport com.example.hungdm.utils.AppUtils\nimport kotlinx.coroutines.flow.update\nimport java.io.BufferedInputStream\nimport java.io.File\nimport java.io.FileOutputStream\nimport java.io.IOException\nimport java.net.HttpURLConnection\nimport java.net.URL\nimport java.net.UnknownHostException\n\nclass MviViewModel(\n    private val userRepository: UserRepository,\n    private val playlistRepository: PlaylistRepository\n) : ViewModel() {\n\n    private val _state \u003d MutableStateFlow(MviState())\n    val state: StateFlow\u003cMviState\u003e \u003d _state.asStateFlow()\n    private val _event \u003d MutableSharedFlow\u003cMviEvent\u003e()\n    val event: SharedFlow\u003cMviEvent\u003e \u003d _event.asSharedFlow()\n\n    init {\n        viewModelScope.launch {\n            AppService.playerPlaylist.collect { playerPlaylist -\u003e\n                _state.update { it.copy(playerPlaylist \u003d playerPlaylist) }\n            }\n        }\n        viewModelScope.launch {\n            AppService.playerListSong.collect { playerListSong -\u003e\n                _state.update { it.copy(playerListSong \u003d playerListSong) }\n            }\n        }\n        viewModelScope.launch {\n            AppService.playerSong.collect { playerSong -\u003e\n                _state.update { it.copy(playerSong \u003d playerSong) }\n            }\n        }\n        viewModelScope.launch {\n            AppService.playerSongIndex.collect { playerSongIndex -\u003e\n                _state.update { it.copy(playerSongIndex \u003d playerSongIndex) }\n            }\n        }\n        viewModelScope.launch {\n            AppService.playerTime.collect { playerTime -\u003e\n                _state.update { it.copy(playerTime \u003d playerTime) }\n            }\n        }\n        viewModelScope.launch {\n            AppService.isPlay.collect { isPlay -\u003e\n                _state.update { it.copy(isPlay \u003d isPlay) }\n            }\n        }\n        viewModelScope.launch {\n            AppService.isShuffle.collect { isShuffle -\u003e\n                _state.update { it.copy(isShuffle \u003d isShuffle) }\n            }\n        }\n        viewModelScope.launch {\n            AppService.isRepeat.collect { isRepeat -\u003e\n                _state.update { it.copy(isRepeat \u003d isRepeat) }\n            }\n        }\n    }\n\n    fun processIntent(intent: MviIntent) {\n        viewModelScope.launch {\n            when (intent) {\n                is MviIntent.GetUser -\u003e {\n                    getUser(intent.userId)\n                }\n\n                is MviIntent.OnClickSignup -\u003e {\n                    sendEvent(MviEvent.GotoSignup)\n                }\n\n                is MviIntent.CheckLogin -\u003e {\n                    checkLogin(intent.userInfo, intent.context)\n                }\n\n                is MviIntent.CheckSignup -\u003e {\n                    checkSignup(intent.userInfo)\n                }\n\n                is MviIntent.OnClickProfile -\u003e {\n                    sendEvent(MviEvent.GotoProfile)\n                }\n\n                is MviIntent.EditProfile -\u003e {\n                    editProfile(intent.userInfo)\n                }\n\n                is MviIntent.OnLogout -\u003e {\n                    logout(intent.context)\n                }\n\n                is MviIntent.OnClickSetting -\u003e {\n                    sendEvent(MviEvent.GotoSettings)\n                }\n\n                is MviIntent.ChangeTheme -\u003e {\n                    _state.value \u003d _state.value.copy(darkTheme \u003d !_state.value.darkTheme)\n                }\n\n                is MviIntent.LoadMusicData -\u003e {\n                    _state.value \u003d _state.value.copy(\n                        topAlbums \u003d getTopAlbums(),\n                        topTracks \u003d getTopTracks(),\n                        topArtists \u003d getTopArtists()\n                    )\n                }\n\n                is MviIntent.OnClickSeeAllTopAlbums -\u003e {\n                    sendEvent(MviEvent.GotoTopAlbums)\n                }\n\n                is MviIntent.OnClickSeeAllTopTracks -\u003e {\n                    sendEvent(MviEvent.GotoTopTracks)\n                }\n\n                is MviIntent.OnClickSeeAllTopArtists -\u003e {\n                    sendEvent(MviEvent.GotoTopArtists)\n                }\n\n                is MviIntent.LoadPlaylistsOfUser -\u003e {\n                    _state.value \u003d _state.value.copy(playlists \u003d loadPlaylistOfUser())\n                }\n\n                is MviIntent.LoadSongLocal -\u003e {\n                    val songs \u003d withContext(Dispatchers.IO) {\n                        getSongExternal(intent.context)\n                    }\n                    _state.value \u003d _state.value.copy(listSongLocal \u003d songs)\n                }\n\n                is MviIntent.LoadSongRemote -\u003e {\n                    loadSongRemote(intent.context)\n                }\n\n                is MviIntent.CreatePlaylist -\u003e {\n                    createPlaylist(intent.title)\n                }\n\n                is MviIntent.RenamePlaylist -\u003e {\n                    playlistRepository.renamePlaylist(intent.playlist.id, intent.title)\n                    _state.value \u003d _state.value.copy(playlists \u003d loadPlaylistOfUser())\n                }\n\n                is MviIntent.RemovePlaylist -\u003e {\n                    removePlaylist(intent.context, intent.playlist)\n                }\n\n                is MviIntent.AddSongToPlaylist -\u003e {\n                    addSongToPlaylist(intent.context, intent.song, intent.playlist)\n                }\n\n                is MviIntent.RemoveSongInPlaylist -\u003e {\n                    removeSongInPlaylist(intent.context, intent.song, intent.playlist)\n                }\n\n                is MviIntent.OnClickPlaylistDetail -\u003e {\n                    sendEvent(MviEvent.GotoPlaylistDetail(intent.playlistId))\n                }\n\n                is MviIntent.OnClickPlayer -\u003e {\n                    playSong(intent.song,intent.playerListSong,intent.playerPlaylist,intent.context)\n                }\n\n                is MviIntent.OnChangeSongPlayState -\u003e {\n                    onPauseResume(intent.context)\n                }\n\n                is MviIntent.OnClickNextSong -\u003e {\n                    val tmpIntent \u003d Intent(intent.context, AppService::class.java).apply {\n                        action \u003d AppService.ACTION_NEXT\n                    }\n                    intent.context.startForegroundService(tmpIntent)\n                }\n\n                is MviIntent.OnClickPreviousSong -\u003e {\n                    val tmpIntent \u003d Intent(intent.context, AppService::class.java).apply {\n                        action \u003d AppService.ACTION_PREVIOUS\n                    }\n                    intent.context.startForegroundService(tmpIntent)\n                }\n\n                is MviIntent.OnClickShuffle -\u003e {\n                    val tmpIntent \u003d Intent(intent.context, AppService::class.java).apply {\n                        action \u003d AppService.ACTION_SHUFFLE\n                    }\n                    intent.context.startForegroundService(tmpIntent)\n                }\n\n                is MviIntent.OnClickRepeat -\u003e {\n                    val tmpIntent \u003d Intent(intent.context, AppService::class.java).apply {\n                        action \u003d AppService.ACTION_REPEAT\n                    }\n                    intent.context.startForegroundService(tmpIntent)\n                }\n\n                is MviIntent.OnClickClosePlayer -\u003e {\n                    val tmpIntent \u003d Intent(intent.context, AppService::class.java).apply {\n                        action \u003d AppService.ACTION_CLOSE\n                    }\n                    intent.context.startForegroundService(tmpIntent)\n                }\n            }\n        }\n    }\n\n    private fun sendEvent(event: MviEvent) {\n        viewModelScope.launch {\n            _event.emit(event)\n        }\n    }\n\n    private suspend fun getUser(userId: Long) {\n        val user \u003d withContext(Dispatchers.IO) {\n            userRepository.getUserById(userId)\n        }\n        _state.value \u003d _state.value.copy(userInfo \u003d user!!.toUserInfo())\n    }\n\n    private suspend fun checkLogin(userInfo: UserInfo, context: Context) {\n        val user \u003d withContext(Dispatchers.IO) {\n            userRepository.login(userInfo.username, userInfo.password)\n        }\n        if (user !\u003d null) {\n            _state.value \u003d _state.value.copy(userInfo \u003d user.toUserInfo())\n            AppUtils.saveUser(context, user.userId)\n            sendEvent(MviEvent.GotoHome)\n        } else {\n            sendEvent(MviEvent.ShowToast(\&quot;Login failed\&quot;))\n        }\n    }\n\n    private suspend fun checkSignup(userInfo: UserInfo) {\n        try {\n            val result \u003d withContext(Dispatchers.IO) {\n                userRepository.signup(\n                    username \u003d userInfo.username,\n                    password \u003d userInfo.password,\n                    email \u003d userInfo.email\n                )\n            }\n            if (result \u003e 0) {\n                sendEvent(MviEvent.GotoLogin)\n            } else {\n                sendEvent(MviEvent.ShowToast(\&quot;Username already exists\&quot;))\n            }\n        } catch (e: Exception) {\n            sendEvent(MviEvent.ShowToast(\&quot;Signup failed ${e.message}\&quot;))\n        }\n    }\n\n    private suspend fun editProfile(userInfo: UserInfo) {\n        withContext(Dispatchers.IO) {\n            userRepository.updateUser(userInfo.toUserEntity())\n        }\n        _state.value \u003d _state.value.copy(userInfo \u003d userInfo)\n    }\n\n    private fun logout(context: Context) {\n        AppUtils.clear(context)\n        AppUtils.setAppLanguage(\&quot;en\&quot;, context)\n        val tmpIntent \u003d Intent(context, AppService::class.java).apply {\n            action \u003d AppService.ACTION_CLOSE\n        }\n        context.startService(tmpIntent)\n        _state.value \u003d MviState()\n        sendEvent(MviEvent.GotoLogin)\n    }\n\n    private suspend fun loadSongRemote(context: Context){\n        val dir \u003d File(context.filesDir, _state.value.userInfo.username)\n        if (!dir.exists()) {\n            val songApi \u003d getSongRemote()\n            //delay(1000) // neu k co delay thi songApi \u003d null, vi interface ApiService dunng Call\u003cList\u003cSongRemote\u003e\u003e\n            val songInternal \u003d mutableListOf\u003cSong\u003e()\n            withContext(Dispatchers.IO) {\n                for (i in songApi) {\n                    songInternal.add(\n                        downloadSongToInternalStorage(\n                            context, i.path!!, _state.value.userInfo.username, i.title + \&quot;.mp3\&quot;\n                        )!!\n                    )\n                }\n            }\n            _state.value \u003d _state.value.copy(listSongRemote \u003d songInternal)\n        } else {\n            val songs \u003d\n                getALlSongInternal(context, _state.value.userInfo.username)\n            _state.value \u003d _state.value.copy(listSongRemote \u003d songs)\n        }\n    }\n\n    private suspend fun createPlaylist(title: String){\n        val playlistEntity \u003d PlaylistEntity(\n            title \u003d title,\n            userId \u003d _state.value.userInfo.id\n        )\n        playlistRepository.createPlaylist(playlistEntity)\n        _state.value \u003d _state.value.copy(playlists \u003d loadPlaylistOfUser())\n    }\n\n    private suspend fun loadPlaylistOfUser(): List\u003cPlaylist\u003e {\n        val playlists \u003d mutableListOf\u003cPlaylist\u003e()\n        withContext(Dispatchers.IO) {\n            val playlistWithSongsList \u003d\n                playlistRepository.getPlaylistsWithSongsOfUser(_state.value.userInfo.id)\n            playlistWithSongsList.map {\n                val songs \u003d it.songs.map { songEntity -\u003e\n                    Song(\n                        id \u003d songEntity.songId,\n                        title \u003d songEntity.title,\n                        artist \u003d songEntity.artist,\n                        duration \u003d songEntity.duration,\n                        uri \u003d songEntity.uri,\n                        img \u003d songEntity.img\n                    )\n                }\n                playlists.add(\n                    Playlist(\n                        id \u003d it.playlist.playlistId,\n                        title \u003d it.playlist.title,\n                        listSong \u003d songs.toMutableList()\n                    )\n                )\n            }\n        }\n        return playlists\n    }\n\n    private suspend fun getSongExternal(context: Context): MutableList\u003cSong\u003e {\n        val songs \u003d mutableListOf\u003cSong\u003e()\n        withContext(Dispatchers.IO) {\n            val uri \u003d MediaStore.Audio.Media.EXTERNAL_CONTENT_URI\n            val projection \u003d arrayOf(\n                MediaStore.Audio.Media._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.DURATION,\n                MediaStore.Audio.Albums.ALBUM_ID\n            )\n\n            val selection \u003d \&quot;${MediaStore.Audio.Media.IS_MUSIC} !\u003d 0\&quot;\n\n            val cursor \u003d context.contentResolver.query(\n                uri, projection, selection, null, null\n            )\n            cursor?.use {\n                val idColumn \u003d it.getColumnIndexOrThrow(MediaStore.Audio.Media._ID)\n                val titleColumn \u003d it.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE)\n                val artistColumn \u003d it.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST)\n                val durationColumn \u003d it.getColumnIndexOrThrow(MediaStore.Audio.Media.DURATION)\n                val albumIdColumn \u003d it.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM_ID)\n\n                while (it.moveToNext()) {\n                    val id \u003d it.getLong(idColumn)\n                    val title \u003d it.getString(titleColumn)\n                    val artist \u003d it.getString(artistColumn)\n                    val duration \u003d it.getLong(durationColumn)\n                    val albumId \u003d it.getLong(albumIdColumn)\n                    val songUri \u003d\n                        ContentUris.withAppendedId(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, id)\n                    val img \u003d AppUtils.getAlbumArt(context, albumId)\n                    songs.add(Song(id, title, artist, duration, songUri, img))\n                }\n            }\n        }\n        return songs\n    }\n\n    private suspend fun getALlSongInternal(\n        context: Context,\n        folderName: String\n    ): MutableList\u003cSong\u003e {\n        val songs \u003d mutableListOf\u003cSong\u003e()\n        val dir \u003d File(context.filesDir, folderName)\n        val mp3 \u003d dir.listFiles() ?: return mutableListOf()\n\n        withContext(Dispatchers.IO) {\n            val retriever \u003d MediaMetadataRetriever()\n            for (i in mp3) {\n                try {\n                    retriever.setDataSource(i.absolutePath)\n                    val title \u003d retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_TITLE)\n                        ?: i.nameWithoutExtension\n                    val artist \u003d\n                        retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ARTIST)\n                            ?: \&quot;Unknown Artist\&quot;\n                    val duration \u003d\n                        retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION)\n                            ?.toLongOrNull() ?: 0L\n                    val path \u003d i.absolutePath\n                    val img \u003d retriever.embeddedPicture\n                    songs.add(\n                        Song(\n                            title \u003d title,\n                            artist \u003d artist,\n                            duration \u003d duration,\n                            uri \u003d Uri.fromFile(i),\n                            img \u003d img,\n                            path \u003d path\n                        )\n                    )\n                } catch (e: Exception) {\n                    Log.d(\&quot;getSongInternal\&quot;, e.toString())\n                }\n            }\n        }\n        return songs\n    }\n\n    private suspend fun getSongRemote(): MutableList\u003cSong\u003e \u003d withContext(Dispatchers.IO) {\n        return@withContext try {\n            ApiSongClient.build().getSongRemote().map { it.toSong() }.toMutableList()\n        } catch (e: UnknownHostException) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Khong co mang: ${e.message}\&quot;)\n            mutableListOf()\n        } catch (e: IOException) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Loi IO: ${e.message}\&quot;)\n            mutableListOf()\n        } catch (e: Exception) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Loi khac: ${e.message}\&quot;)\n            mutableListOf()\n        }\n    }\n\n    private suspend fun getTopAlbums(): TopAlbums? \u003d withContext(Dispatchers.IO) {\n        return@withContext try {\n            ApiMusicClient.build().getTopAlbums().topalbums\n        } catch (e: UnknownHostException) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Khong co mang: ${e.message}\&quot;)\n            null\n        } catch (e: IOException) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Loi IO: ${e.message}\&quot;)\n            null\n        } catch (e: Exception) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Loi khac: ${e.message}\&quot;)\n            null\n        }\n    }\n\n    private suspend fun getTopTracks(): TopTracks? \u003d withContext(Dispatchers.IO) {\n        return@withContext try {\n            ApiMusicClient.build().getTopTracks().toptracks\n        } catch (e: UnknownHostException) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Khong co mang: ${e.message}\&quot;)\n            null\n        } catch (e: IOException) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Loi IO: ${e.message}\&quot;)\n            null\n        } catch (e: Exception) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Loi khac: ${e.message}\&quot;)\n            null\n        }\n    }\n\n    private suspend fun getTopArtists(): TopArtists? \u003d withContext(Dispatchers.IO) {\n        return@withContext try {\n            ApiMusicClient.build().getTopArtists().topArtists\n        } catch (e: UnknownHostException) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Khong co mang: ${e.message}\&quot;)\n            null\n        } catch (e: IOException) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Loi IO: ${e.message}\&quot;)\n            null\n        } catch (e: Exception) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Loi khac: ${e.message}\&quot;)\n            null\n        }\n    }\n\n    private suspend fun removeSongInPlaylist(context: Context, song: Song, playlist: Playlist) {\n        withContext(Dispatchers.IO) {\n            playlistRepository.removeSongInPlaylist(song.id, playlist.id)\n            _state.value \u003d _state.value.copy(playlists \u003d loadPlaylistOfUser())\n            if (_state.value.playerPlaylist?.id \u003d\u003d playlist.id) {\n                val newPlaylist \u003d _state.value.playlists.find {\n                    it.id \u003d\u003d playlist.id\n                }\n                if (song.id \u003d\u003d _state.value.playerSong?.id) {\n                    Log.d(\&quot;HungDM\&quot;, \&quot;chay not bai day di\&quot;)\n                }\n                val tmpIntent \u003d Intent(context, AppService::class.java).apply {\n                    action \u003d AppService.ACTION_UPDATE\n                    putExtra(AppService.EXTRA_PLAYLIST, newPlaylist)\n                }\n                context.startForegroundService(tmpIntent)\n            }\n        }\n    }\n\n    private suspend fun addSongToPlaylist(context: Context, song: Song, playlist: Playlist) {\n        withContext(Dispatchers.IO) {\n            val id \u003d playlistRepository.addSong(song.toSongEntity())\n            playlistRepository.addSongToPlaylist(\n                PlaylistSongReference(playlist.id, id)\n            )\n            _state.value \u003d _state.value.copy(playlists \u003d loadPlaylistOfUser())\n            if (_state.value.playerPlaylist?.id \u003d\u003d playlist.id) {\n                val newPlaylist \u003d _state.value.playlists.find {\n                    it.id \u003d\u003d playlist.id\n                }\n                val tmpIntent \u003d Intent(context, AppService::class.java).apply {\n                    action \u003d AppService.ACTION_UPDATE\n                    putExtra(AppService.EXTRA_PLAYLIST, newPlaylist)\n                }\n                context.startForegroundService(tmpIntent)\n            }\n        }\n    }\n\n    private suspend fun removePlaylist(context: Context, playlist: Playlist) {\n        withContext(Dispatchers.IO) {\n            playlistRepository.removePlaylist(playlist.id)\n            playlistRepository.removeAllSongInPlaylist(playlist.id)\n            _state.value \u003d _state.value.copy(playlists \u003d loadPlaylistOfUser())\n            if (_state.value.playerPlaylist?.id \u003d\u003d playlist.id) {\n                val tmpIntent \u003d Intent(context, AppService::class.java).apply {\n                    action \u003d AppService.ACTION_CLOSE\n                }\n                context.startForegroundService(tmpIntent)\n            }\n        }\n    }\n\n    private fun playSong(song: Song, playerListSong: List\u003cSong\u003e?, playerPlaylist: Playlist?, context: Context){\n        val playerSongIndex \u003d playerListSong?.indexOf(song) ?: playerPlaylist!!.listSong.indexOf(song)\n        val tmpIntent \u003d Intent(context, AppService::class.java).apply {\n            action \u003d AppService.ACTION_PLAY\n            putExtra(AppService.EXTRA_PLAYLIST, playerPlaylist)\n            putExtra(\n                AppService.EXTRA_LIST_SONG, ArrayList(playerListSong ?: emptyList())\n            )\n            putExtra(AppService.EXTRA_SONG, song)\n            putExtra(AppService.EXTRA_INDEX, playerSongIndex)\n        }\n        context.startForegroundService(tmpIntent)\n    }\n\n    private fun onPauseResume(context: Context){\n        if (_state.value.isPlay) {\n            val tmpIntent \u003d Intent(context, AppService::class.java).apply {\n                action \u003d AppService.ACTION_PAUSE\n            }\n            context.startForegroundService(tmpIntent)\n        } else {\n            val tmpIntent \u003d Intent(context, AppService::class.java).apply {\n                action \u003d AppService.ACTION_RESUME\n            }\n            context.startForegroundService(tmpIntent)\n        }\n    }\n\n    private suspend fun downloadSongToInternalStorage(\n        context: Context,\n        fileUrl: String,\n        folderName: String,\n        fileName: String\n    ): Song? {\n        val dir \u003d File(context.filesDir, folderName)\n        if (!dir.exists()) dir.mkdir()\n        val file \u003d File(dir, fileName)\n        if (file.exists()) return null\n\n        return try {\n            var song: Song?\n            withContext(Dispatchers.IO) {\n                val url \u003d URL(fileUrl)\n                val connection \u003d withContext(Dispatchers.IO) {\n                    url.openConnection()\n                } as HttpURLConnection\n                connection.connectTimeout \u003d 5000\n                connection.readTimeout \u003d 5000\n                connection.requestMethod \u003d \&quot;GET\&quot;\n                connection.doInput \u003d true\n                connection.connect()\n\n                if (connection.responseCode !\u003d HttpURLConnection.HTTP_OK) {\n                    throw IOException(\&quot;HTTP error code: ${connection.responseCode}\&quot;)\n                }\n\n                val inputStream \u003d BufferedInputStream(connection.inputStream)\n                val outputStream \u003d FileOutputStream(file)\n\n                inputStream.use { input -\u003e\n                    outputStream.use { output -\u003e\n                        input.copyTo(output)\n                    }\n                }\n\n                val retriever \u003d MediaMetadataRetriever()\n                retriever.setDataSource(file.absolutePath)\n\n                val title \u003d retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_TITLE)\n                    ?: file.nameWithoutExtension\n                val artist \u003d retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ARTIST)\n                    ?: \&quot;Unknown Artist\&quot;\n                val duration \u003d\n                    retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION)\n                        ?.toLongOrNull() ?: 0L\n                val uri \u003d Uri.fromFile(file)\n                val img \u003d retriever.embeddedPicture\n                val path \u003d file.absolutePath\n                song \u003d Song(\n                    title \u003d title,\n                    artist \u003d artist,\n                    duration \u003d duration,\n                    uri \u003d uri,\n                    img \u003d img,\n                    path \u003d path\n                )\n            }\n            song\n        } catch (e: Exception) {\n            e.printStackTrace()\n            null\n        }\n    }\n}\n```\n\u003c/current_file\u003e\n\n\n\u003cattached_files\u003e\n\u003cfile_contents\u003e\n```kotlin:app/src/main/java/com/example/hungdm/service/AppService.kt, lines\u003dALL(1-262)\npackage com.example.hungdm.service\n\nimport android.content.Intent\nimport android.media.MediaPlayer\nimport android.os.IBinder\nimport android.util.Log\nimport androidx.lifecycle.LifecycleService\nimport androidx.lifecycle.lifecycleScope\nimport com.example.hungdm.domain.model.Playlist\nimport com.example.hungdm.domain.model.Song\nimport kotlinx.coroutines.Job\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.isActive\nimport kotlinx.coroutines.launch\nimport kotlin.random.Random\nimport kotlin.random.nextInt\n\nclass AppService : LifecycleService() {\n\n    companion object {\n        const val ACTION_PLAY \u003d \&quot;ACTION_PLAY\&quot;\n        const val ACTION_PAUSE \u003d \&quot;ACTION_PAUSE\&quot;\n        const val ACTION_RESUME \u003d \&quot;ACTION_RESUME\&quot;\n        const val ACTION_CLOSE \u003d \&quot;ACTION_CLOSE\&quot;\n        const val ACTION_NEXT \u003d \&quot;ACTION_NEXT\&quot;\n        const val ACTION_PREVIOUS \u003d \&quot;ACTION_PREVIOUS\&quot;\n        const val ACTION_UPDATE \u003d \&quot;ACTION_UPDATE\&quot;\n        const val ACTION_SHUFFLE \u003d \&quot;ACTION_SHUFFLE\&quot;\n        const val ACTION_REPEAT \u003d \&quot;ACTION_REPEAT\&quot;\n        const val EXTRA_PLAYLIST \u003d \&quot;EXTRA_PLAYLIST\&quot;\n        const val EXTRA_LIST_SONG \u003d \&quot;EXTRA_LIST_SONG\&quot;\n        const val EXTRA_INDEX \u003d \&quot;EXTRA_INDEX\&quot;\n        const val EXTRA_SONG \u003d \&quot;EXTRA_SONG\&quot;\n\n        val playerPlaylist: MutableStateFlow\u003cPlaylist?\u003e \u003d MutableStateFlow(null)\n        val playerListSong: MutableStateFlow\u003cList\u003cSong\u003e?\u003e \u003d MutableStateFlow(null)\n        val playerSongIndex: MutableStateFlow\u003cInt?\u003e \u003d MutableStateFlow(null)\n        val playerSong: MutableStateFlow\u003cSong?\u003e \u003d MutableStateFlow(null)\n        val playerTime: MutableStateFlow\u003cLong\u003e \u003d MutableStateFlow(0L)\n        val isPlay: MutableStateFlow\u003cBoolean\u003e \u003d MutableStateFlow(false)\n        val isShuffle: MutableStateFlow\u003cBoolean\u003e \u003d MutableStateFlow(false)\n        val isRepeat: MutableStateFlow\u003cBoolean\u003e \u003d MutableStateFlow(false)\n    }\n\n    private var mediaPlayer: MediaPlayer? \u003d null\n    private var notificationHelper: NotificationHelper? \u003d null\n    private var timeJob: Job? \u003d null\n\n    override fun onCreate() {\n        super.onCreate()\n        notificationHelper \u003d NotificationHelper(this)\n    }\n\n    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {\n        super.onStartCommand(intent, flags, startId)\n        when (intent?.action) {\n            ACTION_PLAY -\u003e {\n                playerPlaylist.value \u003d intent.getParcelableExtra\u003cPlaylist\u003e(EXTRA_PLAYLIST)\n                playerListSong.value \u003d intent.getParcelableArrayListExtra\u003cSong\u003e(EXTRA_LIST_SONG)\n                playerSongIndex.value \u003d intent.getIntExtra(EXTRA_INDEX,0)\n                playerSong.value \u003d intent.getParcelableExtra\u003cSong\u003e(EXTRA_SONG)\n                playerTime.value \u003d 0L\n                isPlay.value \u003d true\n                playSong()\n            }\n            ACTION_PAUSE -\u003e {\n                isPlay.value \u003d false\n                pauseSong()\n            }\n            ACTION_CLOSE -\u003e {\n                playerPlaylist.value \u003d null\n                playerListSong.value \u003d null\n                playerSongIndex.value \u003d null\n                playerSong.value \u003d null\n                playerTime.value \u003d 0L\n                isPlay.value \u003d false\n                closeSong()\n            }\n            ACTION_RESUME -\u003e {\n                isPlay.value \u003d true\n                resumeSong()\n            }\n            ACTION_NEXT -\u003e {\n                if(isShuffle.value){\n                    shuffleSong()\n                } else if(isRepeat.value){\n                    repeatSong()\n                } else nextSong()\n\n            }\n            ACTION_PREVIOUS -\u003e {\n                if(isShuffle.value){\n                    shuffleSong()\n                } else if(isRepeat.value){\n                    repeatSong()\n                } else previousSong()\n            }\n            ACTION_SHUFFLE -\u003e {\n                isShuffle.value \u003d !isShuffle.value\n                isRepeat.value \u003d false\n            }\n            ACTION_REPEAT -\u003e {\n                isRepeat.value \u003d !isRepeat.value\n                isShuffle.value \u003d false\n            }\n            ACTION_UPDATE -\u003e {\n                playerPlaylist.value \u003d intent.getParcelableExtra\u003cPlaylist\u003e(EXTRA_PLAYLIST)\n            }\n        }\n        return START_STICKY\n    }\n\n    override fun onDestroy() {\n        mediaPlayer?.release()\n        mediaPlayer \u003d null\n        stopForeground(true)\n        super.onDestroy()\n    }\n\n    private fun playSong() {\n        try {\n            mediaPlayer?.release()\n            mediaPlayer \u003d MediaPlayer().apply {\n                setDataSource(applicationContext, playerSong.value?.uri!!)\n                prepare()\n                start()\n                isLooping \u003d false\n                setOnCompletionListener {\n                    if(isShuffle.value){\n                        shuffleSong()\n                    } else if(isRepeat.value){\n                        repeatSong()\n                    } else nextSong()\n                }\n            }\n            isPlay.value \u003d true\n            startUpdatingTime()\n            startForeground(\n                1,\n                notificationHelper?.createNotification(playerSong.value?.title!!, isPlay.value)\n            )\n        } catch (e: Exception) {\n            e.printStackTrace()\n        }\n    }\n\n    private fun pauseSong() {\n        timeJob?.cancel()\n        mediaPlayer?.pause()\n        startForeground(\n            1,\n            notificationHelper?.createNotification(playerSong.value?.title!!, isPlay.value)\n        )\n    }\n\n    private fun closeSong() {\n        mediaPlayer?.stop()\n        mediaPlayer?.release()\n        mediaPlayer \u003d null\n        notificationHelper \u003d null\n        stopSelf()\n    }\n\n    private fun resumeSong() {\n        mediaPlayer?.let {\n            if (!it.isPlaying) {\n                it.start()\n                startUpdatingTime()\n                startForeground(\n                    1,\n                    notificationHelper?.createNotification(playerSong.value?.title!!, isPlay.value)\n                )\n            }\n        }\n    }\n\n    private fun nextSong() {\n        if(playerPlaylist.value\u003d\u003dnull){\n            val nextIndex \u003d if (playerSongIndex.value!! \u003e\u003d playerListSong.value!!.size - 1) 0 else playerSongIndex.value!! + 1\n\n            playerSongIndex.value \u003d nextIndex\n            playerSong.value \u003d playerListSong.value!![nextIndex]\n            playerTime.value \u003d 0L\n        } else {\n            val nextIndex \u003d if (playerSongIndex.value!! \u003e\u003d playerPlaylist.value!!.listSong.size - 1) 0 else playerSongIndex.value!! + 1\n\n            playerSongIndex.value \u003d nextIndex\n            playerSong.value \u003d playerPlaylist.value!!.listSong[nextIndex]\n            playerTime.value \u003d 0L\n        }\n\n        playSong()\n    }\n\n    private fun previousSong(){\n        if(playerPlaylist.value\u003d\u003dnull){\n            val preIndex \u003d if (playerSongIndex.value!! \u003c\u003d 0) playerListSong.value!!.size - 1 else playerSongIndex.value!! - 1\n\n            playerSongIndex.value \u003d preIndex\n            playerSong.value \u003d playerListSong.value!![preIndex]\n            playerTime.value \u003d 0L\n        } else {\n            val preIndex \u003d if (playerSongIndex.value!! \u003c\u003d 0) playerPlaylist.value!!.listSong.size - 1 else playerSongIndex.value!! - 1\n\n            playerSongIndex.value \u003d preIndex\n            playerSong.value \u003d playerPlaylist.value!!.listSong[preIndex]\n            playerTime.value \u003d 0L\n        }\n\n        playSong()\n    }\n\n    private fun shuffleSong() {\n        if(playerPlaylist.value\u003d\u003dnull){\n            val nextIndex \u003d Random.nextInt(0, playerListSong.value!!.size)\n\n            playerSongIndex.value \u003d nextIndex\n            playerSong.value \u003d playerListSong.value!![nextIndex]\n            playerTime.value \u003d 0L\n        } else {\n            val nextIndex \u003d Random.nextInt(0, playerPlaylist.value!!.listSong.size)\n\n            playerSongIndex.value \u003d nextIndex\n            playerSong.value \u003d playerPlaylist.value!!.listSong[nextIndex]\n            playerTime.value \u003d 0L\n        }\n\n        playSong()\n    }\n\n    private fun repeatSong() {\n        if(playerPlaylist.value\u003d\u003dnull){\n            val nextIndex \u003d playerSongIndex.value!!\n\n            playerSongIndex.value \u003d nextIndex\n            playerSong.value \u003d playerListSong.value!![nextIndex]\n            playerTime.value \u003d 0L\n        } else {\n            val nextIndex \u003d playerSongIndex.value!!\n\n            playerSongIndex.value \u003d nextIndex\n            playerSong.value \u003d playerPlaylist.value!!.listSong[nextIndex]\n            playerTime.value \u003d 0L\n        }\n\n        playSong()\n    }\n\n\n    private fun startUpdatingTime() {\n        timeJob?.cancel()\n        timeJob \u003d lifecycleScope.launch {\n            while (isActive) {\n                val time \u003d mediaPlayer?.currentPosition?.toLong() ?: 0L\n                playerTime.value \u003d time\n                delay(100)\n            }\n        }\n    }\n}\n\n```\n\u003c/file_contents\u003e\n\n\u003c/attached_files\u003e\n\u003c/additional_data\u003e\n\u003cuser_query\u003e\nbạn đọc code của tôi và có thấy vấn đề nào không\n\u003c/user_query\u003e&quot;}]}]}" />
        <entry key="8da47a7e-7d0c-467f-841d-e848373631f1" value="{&quot;id&quot;:&quot;8da47a7e-7d0c-467f-841d-e848373631f1&quot;,&quot;name&quot;:&quot;[TextContent(type\u003dtext, text\u003d\n\u003cadditional_data\u003e\nBelow are some potentially helpful/relevant pieces of information for figuring out to respond\n\u003ccurrent_file\u003e\n```kotlin:app/src/main/java/com/example/hungdm/mvi/MviViewModel.kt, lines\u003dALL(1-657)\npackage com.example.hungdm.mvi\n\nimport android.content.ContentUris\nimport android.content.Context\nimport android.content.Intent\nimport android.media.MediaMetadataRetriever\nimport android.net.Uri\nimport android.provider.MediaStore\nimport android.util.Log\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.example.hungdm.data.db.entity.PlaylistEntity\nimport com.example.hungdm.data.db.entity.PlaylistSongReference\nimport com.example.hungdm.data.mapper.toSong\nimport com.example.hungdm.domain.model.Playlist\nimport com.example.hungdm.domain.model.Song\nimport com.example.hungdm.domain.repo.PlaylistRepository\nimport com.example.hungdm.domain.repo.UserRepository\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.flow.MutableSharedFlow\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.SharedFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.asSharedFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.withContext\nimport com.example.hungdm.data.mapper.toSongEntity\nimport com.example.hungdm.data.mapper.toUserEntity\nimport com.example.hungdm.data.mapper.toUserInfo\nimport com.example.hungdm.data.remote.musicApi.ApiMusicClient\nimport com.example.hungdm.data.remote.musicApi.dto.TopAlbums\nimport com.example.hungdm.data.remote.musicApi.dto.TopArtists\nimport com.example.hungdm.data.remote.musicApi.dto.TopTracks\nimport com.example.hungdm.data.remote.songApi.ApiSongClient\nimport com.example.hungdm.domain.model.UserInfo\nimport com.example.hungdm.service.AppService\nimport com.example.hungdm.utils.AppUtils\nimport kotlinx.coroutines.flow.update\nimport java.io.BufferedInputStream\nimport java.io.File\nimport java.io.FileOutputStream\nimport java.io.IOException\nimport java.net.HttpURLConnection\nimport java.net.URL\nimport java.net.UnknownHostException\n\nclass MviViewModel(\n    private val userRepository: UserRepository,\n    private val playlistRepository: PlaylistRepository\n) : ViewModel() {\n\n    private val _state \u003d MutableStateFlow(MviState())\n    val state: StateFlow\u003cMviState\u003e \u003d _state.asStateFlow()\n    private val _event \u003d MutableSharedFlow\u003cMviEvent\u003e()\n    val event: SharedFlow\u003cMviEvent\u003e \u003d _event.asSharedFlow()\n\n    init {\n        viewModelScope.launch {\n            AppService.playerPlaylist.collect { playerPlaylist -\u003e\n                _state.update { it.copy(playerPlaylist \u003d playerPlaylist) }\n            }\n        }\n        viewModelScope.launch {\n            AppService.playerListSong.collect { playerListSong -\u003e\n                _state.update { it.copy(playerListSong \u003d playerListSong) }\n            }\n        }\n        viewModelScope.launch {\n            AppService.playerSong.collect { playerSong -\u003e\n                _state.update { it.copy(playerSong \u003d playerSong) }\n            }\n        }\n        viewModelScope.launch {\n            AppService.playerSongIndex.collect { playerSongIndex -\u003e\n                _state.update { it.copy(playerSongIndex \u003d playerSongIndex) }\n            }\n        }\n        viewModelScope.launch {\n            AppService.playerTime.collect { playerTime -\u003e\n                _state.update { it.copy(playerTime \u003d playerTime) }\n            }\n        }\n        viewModelScope.launch {\n            AppService.isPlay.collect { isPlay -\u003e\n                _state.update { it.copy(isPlay \u003d isPlay) }\n            }\n        }\n        viewModelScope.launch {\n            AppService.isShuffle.collect { isShuffle -\u003e\n                _state.update { it.copy(isShuffle \u003d isShuffle) }\n            }\n        }\n        viewModelScope.launch {\n            AppService.isRepeat.collect { isRepeat -\u003e\n                _state.update { it.copy(isRepeat \u003d isRepeat) }\n            }\n        }\n    }\n\n    fun processIntent(intent: MviIntent) {\n        viewModelScope.launch {\n            when (intent) {\n                is MviIntent.GetUser -\u003e {\n                    getUser(intent.userId)\n                }\n\n                is MviIntent.OnClickSignup -\u003e {\n                    sendEvent(MviEvent.GotoSignup)\n                }\n\n                is MviIntent.CheckLogin -\u003e {\n                    checkLogin(intent.userInfo, intent.context)\n                }\n\n                is MviIntent.CheckSignup -\u003e {\n                    checkSignup(intent.userInfo)\n                }\n\n                is MviIntent.OnClickProfile -\u003e {\n                    sendEvent(MviEvent.GotoProfile)\n                }\n\n                is MviIntent.EditProfile -\u003e {\n                    editProfile(intent.userInfo)\n                }\n\n                is MviIntent.OnLogout -\u003e {\n                    logout(intent.context)\n                }\n\n                is MviIntent.OnClickSetting -\u003e {\n                    sendEvent(MviEvent.GotoSettings)\n                }\n\n                is MviIntent.ChangeTheme -\u003e {\n                    _state.value \u003d _state.value.copy(darkTheme \u003d !_state.value.darkTheme)\n                }\n\n                is MviIntent.LoadMusicData -\u003e {\n                    _state.value \u003d _state.value.copy(\n                        topAlbums \u003d getTopAlbums(),\n                        topTracks \u003d getTopTracks(),\n                        topArtists \u003d getTopArtists()\n                    )\n                }\n\n                is MviIntent.OnClickSeeAllTopAlbums -\u003e {\n                    sendEvent(MviEvent.GotoTopAlbums)\n                }\n\n                is MviIntent.OnClickSeeAllTopTracks -\u003e {\n                    sendEvent(MviEvent.GotoTopTracks)\n                }\n\n                is MviIntent.OnClickSeeAllTopArtists -\u003e {\n                    sendEvent(MviEvent.GotoTopArtists)\n                }\n\n                is MviIntent.LoadPlaylistsOfUser -\u003e {\n                    _state.value \u003d _state.value.copy(playlists \u003d loadPlaylistOfUser())\n                }\n\n                is MviIntent.LoadSongLocal -\u003e {\n                    val songs \u003d withContext(Dispatchers.IO) {\n                        getSongExternal(intent.context)\n                    }\n                    _state.value \u003d _state.value.copy(listSongLocal \u003d songs)\n                }\n\n                is MviIntent.LoadSongRemote -\u003e {\n                    loadSongRemote(intent.context)\n                }\n\n                is MviIntent.CreatePlaylist -\u003e {\n                    createPlaylist(intent.title)\n                }\n\n                is MviIntent.RenamePlaylist -\u003e {\n                    playlistRepository.renamePlaylist(intent.playlist.id, intent.title)\n                    _state.value \u003d _state.value.copy(playlists \u003d loadPlaylistOfUser())\n                }\n\n                is MviIntent.RemovePlaylist -\u003e {\n                    removePlaylist(intent.context, intent.playlist)\n                }\n\n                is MviIntent.AddSongToPlaylist -\u003e {\n                    addSongToPlaylist(intent.context, intent.song, intent.playlist)\n                }\n\n                is MviIntent.RemoveSongInPlaylist -\u003e {\n                    removeSongInPlaylist(intent.context, intent.song, intent.playlist)\n                }\n\n                is MviIntent.OnClickPlaylistDetail -\u003e {\n                    sendEvent(MviEvent.GotoPlaylistDetail(intent.playlistId))\n                }\n\n                is MviIntent.OnClickPlayer -\u003e {\n                    playSong(intent.song,intent.playerListSong,intent.playerPlaylist,intent.context)\n                }\n\n                is MviIntent.OnChangeSongPlayState -\u003e {\n                    onPauseResume(intent.context)\n                }\n\n                is MviIntent.OnClickNextSong -\u003e {\n                    val tmpIntent \u003d Intent(intent.context, AppService::class.java).apply {\n                        action \u003d AppService.ACTION_NEXT\n                    }\n                    intent.context.startForegroundService(tmpIntent)\n                }\n\n                is MviIntent.OnClickPreviousSong -\u003e {\n                    val tmpIntent \u003d Intent(intent.context, AppService::class.java).apply {\n                        action \u003d AppService.ACTION_PREVIOUS\n                    }\n                    intent.context.startForegroundService(tmpIntent)\n                }\n\n                is MviIntent.OnClickShuffle -\u003e {\n                    val tmpIntent \u003d Intent(intent.context, AppService::class.java).apply {\n                        action \u003d AppService.ACTION_SHUFFLE\n                    }\n                    intent.context.startForegroundService(tmpIntent)\n                }\n\n                is MviIntent.OnClickRepeat -\u003e {\n                    val tmpIntent \u003d Intent(intent.context, AppService::class.java).apply {\n                        action \u003d AppService.ACTION_REPEAT\n                    }\n                    intent.context.startForegroundService(tmpIntent)\n                }\n\n                is MviIntent.OnClickClosePlayer -\u003e {\n                    val tmpIntent \u003d Intent(intent.context, AppService::class.java).apply {\n                        action \u003d AppService.ACTION_CLOSE\n                    }\n                    intent.context.startForegroundService(tmpIntent)\n                }\n            }\n        }\n    }\n\n    private fun sendEvent(event: MviEvent) {\n        viewModelScope.launch {\n            _event.emit(event)\n        }\n    }\n\n    private suspend fun getUser(userId: Long) {\n        val user \u003d withContext(Dispatchers.IO) {\n            userRepository.getUserById(userId)\n        }\n        _state.value \u003d _state.value.copy(userInfo \u003d user!!.toUserInfo())\n    }\n\n    private suspend fun checkLogin(userInfo: UserInfo, context: Context) {\n        val user \u003d withContext(Dispatchers.IO) {\n            userRepository.login(userInfo.username, userInfo.password)\n        }\n        if (user !\u003d null) {\n            _state.value \u003d _state.value.copy(userInfo \u003d user.toUserInfo())\n            AppUtils.saveUser(context, user.userId)\n            sendEvent(MviEvent.GotoHome)\n        } else {\n            sendEvent(MviEvent.ShowToast(\&quot;Login failed\&quot;))\n        }\n    }\n\n    private suspend fun checkSignup(userInfo: UserInfo) {\n        try {\n            val result \u003d withContext(Dispatchers.IO) {\n                userRepository.signup(\n                    username \u003d userInfo.username,\n                    password \u003d userInfo.password,\n                    email \u003d userInfo.email\n                )\n            }\n            if (result \u003e 0) {\n                sendEvent(MviEvent.GotoLogin)\n            } else {\n                sendEvent(MviEvent.ShowToast(\&quot;Username already exists\&quot;))\n            }\n        } catch (e: Exception) {\n            sendEvent(MviEvent.ShowToast(\&quot;Signup failed ${e.message}\&quot;))\n        }\n    }\n\n    private suspend fun editProfile(userInfo: UserInfo) {\n        withContext(Dispatchers.IO) {\n            userRepository.updateUser(userInfo.toUserEntity())\n        }\n        _state.value \u003d _state.value.copy(userInfo \u003d userInfo)\n    }\n\n    private fun logout(context: Context) {\n        AppUtils.clear(context)\n        AppUtils.setAppLanguage(\&quot;en\&quot;, context)\n        val tmpIntent \u003d Intent(context, AppService::class.java).apply {\n            action \u003d AppService.ACTION_CLOSE\n        }\n        context.startService(tmpIntent)\n        _state.value \u003d MviState()\n        sendEvent(MviEvent.GotoLogin)\n    }\n\n    private suspend fun loadSongRemote(context: Context){\n        val dir \u003d File(context.filesDir, _state.value.userInfo.username)\n        if (!dir.exists()) {\n            val songApi \u003d getSongRemote()\n            //delay(1000) // neu k co delay thi songApi \u003d null, vi interface ApiService dunng Call\u003cList\u003cSongRemote\u003e\u003e\n            val songInternal \u003d mutableListOf\u003cSong\u003e()\n            withContext(Dispatchers.IO) {\n                for (i in songApi) {\n                    songInternal.add(\n                        downloadSongToInternalStorage(\n                            context, i.path!!, _state.value.userInfo.username, i.title + \&quot;.mp3\&quot;\n                        )!!\n                    )\n                }\n            }\n            _state.value \u003d _state.value.copy(listSongRemote \u003d songInternal)\n        } else {\n            val songs \u003d\n                getALlSongInternal(context, _state.value.userInfo.username)\n            _state.value \u003d _state.value.copy(listSongRemote \u003d songs)\n        }\n    }\n\n    private suspend fun createPlaylist(title: String){\n        val playlistEntity \u003d PlaylistEntity(\n            title \u003d title,\n            userId \u003d _state.value.userInfo.id\n        )\n        playlistRepository.createPlaylist(playlistEntity)\n        _state.value \u003d _state.value.copy(playlists \u003d loadPlaylistOfUser())\n    }\n\n    private suspend fun loadPlaylistOfUser(): List\u003cPlaylist\u003e {\n        val playlists \u003d mutableListOf\u003cPlaylist\u003e()\n        withContext(Dispatchers.IO) {\n            val playlistWithSongsList \u003d\n                playlistRepository.getPlaylistsWithSongsOfUser(_state.value.userInfo.id)\n            playlistWithSongsList.map {\n                val songs \u003d it.songs.map { songEntity -\u003e\n                    Song(\n                        id \u003d songEntity.songId,\n                        title \u003d songEntity.title,\n                        artist \u003d songEntity.artist,\n                        duration \u003d songEntity.duration,\n                        uri \u003d songEntity.uri,\n                        img \u003d songEntity.img\n                    )\n                }\n                playlists.add(\n                    Playlist(\n                        id \u003d it.playlist.playlistId,\n                        title \u003d it.playlist.title,\n                        listSong \u003d songs.toMutableList()\n                    )\n                )\n            }\n        }\n        return playlists\n    }\n\n    private suspend fun getSongExternal(context: Context): MutableList\u003cSong\u003e {\n        val songs \u003d mutableListOf\u003cSong\u003e()\n        withContext(Dispatchers.IO) {\n            val uri \u003d MediaStore.Audio.Media.EXTERNAL_CONTENT_URI\n            val projection \u003d arrayOf(\n                MediaStore.Audio.Media._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.DURATION,\n                MediaStore.Audio.Albums.ALBUM_ID\n            )\n\n            val selection \u003d \&quot;${MediaStore.Audio.Media.IS_MUSIC} !\u003d 0\&quot;\n\n            val cursor \u003d context.contentResolver.query(\n                uri, projection, selection, null, null\n            )\n            cursor?.use {\n                val idColumn \u003d it.getColumnIndexOrThrow(MediaStore.Audio.Media._ID)\n                val titleColumn \u003d it.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE)\n                val artistColumn \u003d it.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST)\n                val durationColumn \u003d it.getColumnIndexOrThrow(MediaStore.Audio.Media.DURATION)\n                val albumIdColumn \u003d it.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM_ID)\n\n                while (it.moveToNext()) {\n                    val id \u003d it.getLong(idColumn)\n                    val title \u003d it.getString(titleColumn)\n                    val artist \u003d it.getString(artistColumn)\n                    val duration \u003d it.getLong(durationColumn)\n                    val albumId \u003d it.getLong(albumIdColumn)\n                    val songUri \u003d\n                        ContentUris.withAppendedId(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, id)\n                    val img \u003d AppUtils.getAlbumArt(context, albumId)\n                    songs.add(Song(id, title, artist, duration, songUri, img))\n                }\n            }\n        }\n        return songs\n    }\n\n    private suspend fun getALlSongInternal(\n        context: Context,\n        folderName: String\n    ): MutableList\u003cSong\u003e {\n        val songs \u003d mutableListOf\u003cSong\u003e()\n        val dir \u003d File(context.filesDir, folderName)\n        val mp3 \u003d dir.listFiles() ?: return mutableListOf()\n\n        withContext(Dispatchers.IO) {\n            val retriever \u003d MediaMetadataRetriever()\n            for (i in mp3) {\n                try {\n                    retriever.setDataSource(i.absolutePath)\n                    val title \u003d retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_TITLE)\n                        ?: i.nameWithoutExtension\n                    val artist \u003d\n                        retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ARTIST)\n                            ?: \&quot;Unknown Artist\&quot;\n                    val duration \u003d\n                        retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION)\n                            ?.toLongOrNull() ?: 0L\n                    val path \u003d i.absolutePath\n                    val img \u003d retriever.embeddedPicture\n                    songs.add(\n                        Song(\n                            title \u003d title,\n                            artist \u003d artist,\n                            duration \u003d duration,\n                            uri \u003d Uri.fromFile(i),\n                            img \u003d img,\n                            path \u003d path\n                        )\n                    )\n                } catch (e: Exception) {\n                    Log.d(\&quot;getSongInternal\&quot;, e.toString())\n                }\n            }\n        }\n        return songs\n    }\n\n    private suspend fun getSongRemote(): MutableList\u003cSong\u003e \u003d withContext(Dispatchers.IO) {\n        return@withContext try {\n            ApiSongClient.build().getSongRemote().map { it.toSong() }.toMutableList()\n        } catch (e: UnknownHostException) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Khong co mang: ${e.message}\&quot;)\n            mutableListOf()\n        } catch (e: IOException) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Loi IO: ${e.message}\&quot;)\n            mutableListOf()\n        } catch (e: Exception) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Loi khac: ${e.message}\&quot;)\n            mutableListOf()\n        }\n    }\n\n    private suspend fun getTopAlbums(): TopAlbums? \u003d withContext(Dispatchers.IO) {\n        return@withContext try {\n            ApiMusicClient.build().getTopAlbums().topalbums\n        } catch (e: UnknownHostException) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Khong co mang: ${e.message}\&quot;)\n            null\n        } catch (e: IOException) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Loi IO: ${e.message}\&quot;)\n            null\n        } catch (e: Exception) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Loi khac: ${e.message}\&quot;)\n            null\n        }\n    }\n\n    private suspend fun getTopTracks(): TopTracks? \u003d withContext(Dispatchers.IO) {\n        return@withContext try {\n            ApiMusicClient.build().getTopTracks().toptracks\n        } catch (e: UnknownHostException) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Khong co mang: ${e.message}\&quot;)\n            null\n        } catch (e: IOException) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Loi IO: ${e.message}\&quot;)\n            null\n        } catch (e: Exception) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Loi khac: ${e.message}\&quot;)\n            null\n        }\n    }\n\n    private suspend fun getTopArtists(): TopArtists? \u003d withContext(Dispatchers.IO) {\n        return@withContext try {\n            ApiMusicClient.build().getTopArtists().topArtists\n        } catch (e: UnknownHostException) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Khong co mang: ${e.message}\&quot;)\n            null\n        } catch (e: IOException) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Loi IO: ${e.message}\&quot;)\n            null\n        } catch (e: Exception) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Loi khac: ${e.message}\&quot;)\n            null\n        }\n    }\n\n    private suspend fun removeSongInPlaylist(context: Context, song: Song, playlist: Playlist) {\n        withContext(Dispatchers.IO) {\n            playlistRepository.removeSongInPlaylist(song.id, playlist.id)\n            _state.value \u003d _state.value.copy(playlists \u003d loadPlaylistOfUser())\n            if (_state.value.playerPlaylist?.id \u003d\u003d playlist.id) {\n                val newPlaylist \u003d _state.value.playlists.find {\n                    it.id \u003d\u003d playlist.id\n                }\n                if (song.id \u003d\u003d _state.value.playerSong?.id) {\n                    Log.d(\&quot;HungDM\&quot;, \&quot;chay not bai day di\&quot;)\n                }\n                val tmpIntent \u003d Intent(context, AppService::class.java).apply {\n                    action \u003d AppService.ACTION_UPDATE\n                    putExtra(AppService.EXTRA_PLAYLIST, newPlaylist)\n                }\n                context.startForegroundService(tmpIntent)\n            }\n        }\n    }\n\n    private suspend fun addSongToPlaylist(context: Context, song: Song, playlist: Playlist) {\n        withContext(Dispatchers.IO) {\n            val id \u003d playlistRepository.addSong(song.toSongEntity())\n            playlistRepository.addSongToPlaylist(\n                PlaylistSongReference(playlist.id, id)\n            )\n            _state.value \u003d _state.value.copy(playlists \u003d loadPlaylistOfUser())\n            if (_state.value.playerPlaylist?.id \u003d\u003d playlist.id) {\n                val newPlaylist \u003d _state.value.playlists.find {\n                    it.id \u003d\u003d playlist.id\n                }\n                val tmpIntent \u003d Intent(context, AppService::class.java).apply {\n                    action \u003d AppService.ACTION_UPDATE\n                    putExtra(AppService.EXTRA_PLAYLIST, newPlaylist)\n                }\n                context.startForegroundService(tmpIntent)\n            }\n        }\n    }\n\n    private suspend fun removePlaylist(context: Context, playlist: Playlist) {\n        withContext(Dispatchers.IO) {\n            playlistRepository.removePlaylist(playlist.id)\n            playlistRepository.removeAllSongInPlaylist(playlist.id)\n            _state.value \u003d _state.value.copy(playlists \u003d loadPlaylistOfUser())\n            if (_state.value.playerPlaylist?.id \u003d\u003d playlist.id) {\n                val tmpIntent \u003d Intent(context, AppService::class.java).apply {\n                    action \u003d AppService.ACTION_CLOSE\n                }\n                context.startForegroundService(tmpIntent)\n            }\n        }\n    }\n\n    private fun playSong(song: Song, playerListSong: List\u003cSong\u003e?, playerPlaylist: Playlist?, context: Context){\n        val playerSongIndex \u003d playerListSong?.indexOf(song) ?: playerPlaylist!!.listSong.indexOf(song)\n        val tmpIntent \u003d Intent(context, AppService::class.java).apply {\n            action \u003d AppService.ACTION_PLAY\n            putExtra(AppService.EXTRA_PLAYLIST, playerPlaylist)\n            putExtra(\n                AppService.EXTRA_LIST_SONG, ArrayList(playerListSong ?: emptyList())\n            )\n            putExtra(AppService.EXTRA_SONG, song)\n            putExtra(AppService.EXTRA_INDEX, playerSongIndex)\n        }\n        context.startForegroundService(tmpIntent)\n    }\n\n    private fun onPauseResume(context: Context){\n        if (_state.value.isPlay) {\n            val tmpIntent \u003d Intent(context, AppService::class.java).apply {\n                action \u003d AppService.ACTION_PAUSE\n            }\n            context.startForegroundService(tmpIntent)\n        } else {\n            val tmpIntent \u003d Intent(context, AppService::class.java).apply {\n                action \u003d AppService.ACTION_RESUME\n            }\n            context.startForegroundService(tmpIntent)\n        }\n    }\n\n    private suspend fun downloadSongToInternalStorage(\n        context: Context,\n        fileUrl: String,\n        folderName: String,\n        fileName: String\n    ): Song? {\n        val dir \u003d File(context.filesDir, folderName)\n        if (!dir.exists()) dir.mkdir()\n        val file \u003d File(dir, fileName)\n        if (file.exists()) return null\n\n        return try {\n            var song: Song?\n            withContext(Dispatchers.IO) {\n                val url \u003d URL(fileUrl)\n                val connection \u003d withContext(Dispatchers.IO) {\n                    url.openConnection()\n                } as HttpURLConnection\n                connection.connectTimeout \u003d 5000\n                connection.readTimeout \u003d 5000\n                connection.requestMethod \u003d \&quot;GET\&quot;\n                connection.doInput \u003d true\n                connection.connect()\n\n                if (connection.responseCode !\u003d HttpURLConnection.HTTP_OK) {\n                    throw IOException(\&quot;HTTP error code: ${connection.responseCode}\&quot;)\n                }\n\n                val inputStream \u003d BufferedInputStream(connection.inputStream)\n                val outputStream \u003d FileOutputStream(file)\n\n                inputStream.use { input -\u003e\n                    outputStream.use { output -\u003e\n                        input.copyTo(output)\n                    }\n                }\n\n                val retriever \u003d MediaMetadataRetriever()\n                retriever.setDataSource(file.absolutePath)\n\n                val title \u003d retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_TITLE)\n                    ?: file.nameWithoutExtension\n                val artist \u003d retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ARTIST)\n                    ?: \&quot;Unknown Artist\&quot;\n                val duration \u003d\n                    retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION)\n                        ?.toLongOrNull() ?: 0L\n                val uri \u003d Uri.fromFile(file)\n                val img \u003d retriever.embeddedPicture\n                val path \u003d file.absolutePath\n                song \u003d Song(\n                    title \u003d title,\n                    artist \u003d artist,\n                    duration \u003d duration,\n                    uri \u003d uri,\n                    img \u003d img,\n                    path \u003d path\n                )\n            }\n            song\n        } catch (e: Exception) {\n            e.printStackTrace()\n            null\n        }\n    }\n}\n```\n\u003c/current_file\u003e\n\n\n\u003cattached_files\u003e\n\u003cfile_contents\u003e\n```kotlin:app/src/main/java/com/example/hungdm/service/AppService.kt, lines\u003dALL(1-262)\npackage com.example.hungdm.service\n\nimport android.content.Intent\nimport android.media.MediaPlayer\nimport android.os.IBinder\nimport android.util.Log\nimport androidx.lifecycle.LifecycleService\nimport androidx.lifecycle.lifecycleScope\nimport com.example.hungdm.domain.model.Playlist\nimport com.example.hungdm.domain.model.Song\nimport kotlinx.coroutines.Job\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.isActive\nimport kotlinx.coroutines.launch\nimport kotlin.random.Random\nimport kotlin.random.nextInt\n\nclass AppService : LifecycleService() {\n\n    companion object {\n        const val ACTION_PLAY \u003d \&quot;ACTION_PLAY\&quot;\n        const val ACTION_PAUSE \u003d \&quot;ACTION_PAUSE\&quot;\n        const val ACTION_RESUME \u003d \&quot;ACTION_RESUME\&quot;\n        const val ACTION_CLOSE \u003d \&quot;ACTION_CLOSE\&quot;\n        const val ACTION_NEXT \u003d \&quot;ACTION_NEXT\&quot;\n        const val ACTION_PREVIOUS \u003d \&quot;ACTION_PREVIOUS\&quot;\n        const val ACTION_UPDATE \u003d \&quot;ACTION_UPDATE\&quot;\n        const val ACTION_SHUFFLE \u003d \&quot;ACTION_SHUFFLE\&quot;\n        const val ACTION_REPEAT \u003d \&quot;ACTION_REPEAT\&quot;\n        const val EXTRA_PLAYLIST \u003d \&quot;EXTRA_PLAYLIST\&quot;\n        const val EXTRA_LIST_SONG \u003d \&quot;EXTRA_LIST_SONG\&quot;\n        const val EXTRA_INDEX \u003d \&quot;EXTRA_INDEX\&quot;\n        const val EXTRA_SONG \u003d \&quot;EXTRA_SONG\&quot;\n\n        val playerPlaylist: MutableStateFlow\u003cPlaylist?\u003e \u003d MutableStateFlow(null)\n        val playerListSong: MutableStateFlow\u003cList\u003cSong\u003e?\u003e \u003d MutableStateFlow(null)\n        val playerSongIndex: MutableStateFlow\u003cInt?\u003e \u003d MutableStateFlow(null)\n        val playerSong: MutableStateFlow\u003cSong?\u003e \u003d MutableStateFlow(null)\n        val playerTime: MutableStateFlow\u003cLong\u003e \u003d MutableStateFlow(0L)\n        val isPlay: MutableStateFlow\u003cBoolean\u003e \u003d MutableStateFlow(false)\n        val isShuffle: MutableStateFlow\u003cBoolean\u003e \u003d MutableStateFlow(false)\n        val isRepeat: MutableStateFlow\u003cBoolean\u003e \u003d MutableStateFlow(false)\n    }\n\n    private var mediaPlayer: MediaPlayer? \u003d null\n    private var notificationHelper: NotificationHelper? \u003d null\n    private var timeJob: Job? \u003d null\n\n    override fun onCreate() {\n        super.onCreate()\n        notificationHelper \u003d NotificationHelper(this)\n    }\n\n    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {\n        super.onStartCommand(intent, flags, startId)\n        when (intent?.action) {\n            ACTION_PLAY -\u003e {\n                playerPlaylist.value \u003d intent.getParcelableExtra\u003cPlaylist\u003e(EXTRA_PLAYLIST)\n                playerListSong.value \u003d intent.getParcelableArrayListExtra\u003cSong\u003e(EXTRA_LIST_SONG)\n                playerSongIndex.value \u003d intent.getIntExtra(EXTRA_INDEX,0)\n                playerSong.value \u003d intent.getParcelableExtra\u003cSong\u003e(EXTRA_SONG)\n                playerTime.value \u003d 0L\n                isPlay.value \u003d true\n                playSong()\n            }\n            ACTION_PAUSE -\u003e {\n                isPlay.value \u003d false\n                pauseSong()\n            }\n            ACTION_CLOSE -\u003e {\n                playerPlaylist.value \u003d null\n                playerListSong.value \u003d null\n                playerSongIndex.value \u003d null\n                playerSong.value \u003d null\n                playerTime.value \u003d 0L\n                isPlay.value \u003d false\n                closeSong()\n            }\n            ACTION_RESUME -\u003e {\n                isPlay.value \u003d true\n                resumeSong()\n            }\n            ACTION_NEXT -\u003e {\n                if(isShuffle.value){\n                    shuffleSong()\n                } else if(isRepeat.value){\n                    repeatSong()\n                } else nextSong()\n\n            }\n            ACTION_PREVIOUS -\u003e {\n                if(isShuffle.value){\n                    shuffleSong()\n                } else if(isRepeat.value){\n                    repeatSong()\n                } else previousSong()\n            }\n            ACTION_SHUFFLE -\u003e {\n                isShuffle.value \u003d !isShuffle.value\n                isRepeat.value \u003d false\n            }\n            ACTION_REPEAT -\u003e {\n                isRepeat.value \u003d !isRepeat.value\n                isShuffle.value \u003d false\n            }\n            ACTION_UPDATE -\u003e {\n                playerPlaylist.value \u003d intent.getParcelableExtra\u003cPlaylist\u003e(EXTRA_PLAYLIST)\n            }\n        }\n        return START_STICKY\n    }\n\n    override fun onDestroy() {\n        mediaPlayer?.release()\n        mediaPlayer \u003d null\n        stopForeground(true)\n        super.onDestroy()\n    }\n\n    private fun playSong() {\n        try {\n            mediaPlayer?.release()\n            mediaPlayer \u003d MediaPlayer().apply {\n                setDataSource(applicationContext, playerSong.value?.uri!!)\n                prepare()\n                start()\n                isLooping \u003d false\n                setOnCompletionListener {\n                    if(isShuffle.value){\n                        shuffleSong()\n                    } else if(isRepeat.value){\n                        repeatSong()\n                    } else nextSong()\n                }\n            }\n            isPlay.value \u003d true\n            startUpdatingTime()\n            startForeground(\n                1,\n                notificationHelper?.createNotification(playerSong.value?.title!!, isPlay.value)\n            )\n        } catch (e: Exception) {\n            e.printStackTrace()\n        }\n    }\n\n    private fun pauseSong() {\n        timeJob?.cancel()\n        mediaPlayer?.pause()\n        startForeground(\n            1,\n            notificationHelper?.createNotification(playerSong.value?.title!!, isPlay.value)\n        )\n    }\n\n    private fun closeSong() {\n        mediaPlayer?.stop()\n        mediaPlayer?.release()\n        mediaPlayer \u003d null\n        notificationHelper \u003d null\n        stopSelf()\n    }\n\n    private fun resumeSong() {\n        mediaPlayer?.let {\n            if (!it.isPlaying) {\n                it.start()\n                startUpdatingTime()\n                startForeground(\n                    1,\n                    notificationHelper?.createNotification(playerSong.value?.title!!, isPlay.value)\n                )\n            }\n        }\n    }\n\n    private fun nextSong() {\n        if(playerPlaylist.value\u003d\u003dnull){\n            val nextIndex \u003d if (playerSongIndex.value!! \u003e\u003d playerListSong.value!!.size - 1) 0 else playerSongIndex.value!! + 1\n\n            playerSongIndex.value \u003d nextIndex\n            playerSong.value \u003d playerListSong.value!![nextIndex]\n            playerTime.value \u003d 0L\n        } else {\n            val nextIndex \u003d if (playerSongIndex.value!! \u003e\u003d playerPlaylist.value!!.listSong.size - 1) 0 else playerSongIndex.value!! + 1\n\n            playerSongIndex.value \u003d nextIndex\n            playerSong.value \u003d playerPlaylist.value!!.listSong[nextIndex]\n            playerTime.value \u003d 0L\n        }\n\n        playSong()\n    }\n\n    private fun previousSong(){\n        if(playerPlaylist.value\u003d\u003dnull){\n            val preIndex \u003d if (playerSongIndex.value!! \u003c\u003d 0) playerListSong.value!!.size - 1 else playerSongIndex.value!! - 1\n\n            playerSongIndex.value \u003d preIndex\n            playerSong.value \u003d playerListSong.value!![preIndex]\n            playerTime.value \u003d 0L\n        } else {\n            val preIndex \u003d if (playerSongIndex.value!! \u003c\u003d 0) playerPlaylist.value!!.listSong.size - 1 else playerSongIndex.value!! - 1\n\n            playerSongIndex.value \u003d preIndex\n            playerSong.value \u003d playerPlaylist.value!!.listSong[preIndex]\n            playerTime.value \u003d 0L\n        }\n\n        playSong()\n    }\n\n    private fun shuffleSong() {\n        if(playerPlaylist.value\u003d\u003dnull){\n            val nextIndex \u003d Random.nextInt(0, playerListSong.value!!.size)\n\n            playerSongIndex.value \u003d nextIndex\n            playerSong.value \u003d playerListSong.value!![nextIndex]\n            playerTime.value \u003d 0L\n        } else {\n            val nextIndex \u003d Random.nextInt(0, playerPlaylist.value!!.listSong.size)\n\n            playerSongIndex.value \u003d nextIndex\n            playerSong.value \u003d playerPlaylist.value!!.listSong[nextIndex]\n            playerTime.value \u003d 0L\n        }\n\n        playSong()\n    }\n\n    private fun repeatSong() {\n        if(playerPlaylist.value\u003d\u003dnull){\n            val nextIndex \u003d playerSongIndex.value!!\n\n            playerSongIndex.value \u003d nextIndex\n            playerSong.value \u003d playerListSong.value!![nextIndex]\n            playerTime.value \u003d 0L\n        } else {\n            val nextIndex \u003d playerSongIndex.value!!\n\n            playerSongIndex.value \u003d nextIndex\n            playerSong.value \u003d playerPlaylist.value!!.listSong[nextIndex]\n            playerTime.value \u003d 0L\n        }\n\n        playSong()\n    }\n\n\n    private fun startUpdatingTime() {\n        timeJob?.cancel()\n        timeJob \u003d lifecycleScope.launch {\n            while (isActive) {\n                val time \u003d mediaPlayer?.currentPosition?.toLong() ?: 0L\n                playerTime.value \u003d time\n                delay(100)\n            }\n        }\n    }\n}\n\n```\n\u003c/file_contents\u003e\n\n\u003c/attached_files\u003e\n\u003c/additional_data\u003e\n\u003cuser_query\u003e\nbạn đọc code của tôi và có thấy vấn đề nào không\n\u003c/user_query\u003e)]&quot;,&quot;timestamp&quot;:1755088617816,&quot;messages&quot;:[{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;\n\u003cadditional_data\u003e\nBelow are some potentially helpful/relevant pieces of information for figuring out to respond\n\u003ccurrent_file\u003e\n```kotlin:app/src/main/java/com/example/hungdm/mvi/MviViewModel.kt, lines\u003dALL(1-657)\npackage com.example.hungdm.mvi\n\nimport android.content.ContentUris\nimport android.content.Context\nimport android.content.Intent\nimport android.media.MediaMetadataRetriever\nimport android.net.Uri\nimport android.provider.MediaStore\nimport android.util.Log\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.example.hungdm.data.db.entity.PlaylistEntity\nimport com.example.hungdm.data.db.entity.PlaylistSongReference\nimport com.example.hungdm.data.mapper.toSong\nimport com.example.hungdm.domain.model.Playlist\nimport com.example.hungdm.domain.model.Song\nimport com.example.hungdm.domain.repo.PlaylistRepository\nimport com.example.hungdm.domain.repo.UserRepository\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.flow.MutableSharedFlow\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.SharedFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.asSharedFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.withContext\nimport com.example.hungdm.data.mapper.toSongEntity\nimport com.example.hungdm.data.mapper.toUserEntity\nimport com.example.hungdm.data.mapper.toUserInfo\nimport com.example.hungdm.data.remote.musicApi.ApiMusicClient\nimport com.example.hungdm.data.remote.musicApi.dto.TopAlbums\nimport com.example.hungdm.data.remote.musicApi.dto.TopArtists\nimport com.example.hungdm.data.remote.musicApi.dto.TopTracks\nimport com.example.hungdm.data.remote.songApi.ApiSongClient\nimport com.example.hungdm.domain.model.UserInfo\nimport com.example.hungdm.service.AppService\nimport com.example.hungdm.utils.AppUtils\nimport kotlinx.coroutines.flow.update\nimport java.io.BufferedInputStream\nimport java.io.File\nimport java.io.FileOutputStream\nimport java.io.IOException\nimport java.net.HttpURLConnection\nimport java.net.URL\nimport java.net.UnknownHostException\n\nclass MviViewModel(\n    private val userRepository: UserRepository,\n    private val playlistRepository: PlaylistRepository\n) : ViewModel() {\n\n    private val _state \u003d MutableStateFlow(MviState())\n    val state: StateFlow\u003cMviState\u003e \u003d _state.asStateFlow()\n    private val _event \u003d MutableSharedFlow\u003cMviEvent\u003e()\n    val event: SharedFlow\u003cMviEvent\u003e \u003d _event.asSharedFlow()\n\n    init {\n        viewModelScope.launch {\n            AppService.playerPlaylist.collect { playerPlaylist -\u003e\n                _state.update { it.copy(playerPlaylist \u003d playerPlaylist) }\n            }\n        }\n        viewModelScope.launch {\n            AppService.playerListSong.collect { playerListSong -\u003e\n                _state.update { it.copy(playerListSong \u003d playerListSong) }\n            }\n        }\n        viewModelScope.launch {\n            AppService.playerSong.collect { playerSong -\u003e\n                _state.update { it.copy(playerSong \u003d playerSong) }\n            }\n        }\n        viewModelScope.launch {\n            AppService.playerSongIndex.collect { playerSongIndex -\u003e\n                _state.update { it.copy(playerSongIndex \u003d playerSongIndex) }\n            }\n        }\n        viewModelScope.launch {\n            AppService.playerTime.collect { playerTime -\u003e\n                _state.update { it.copy(playerTime \u003d playerTime) }\n            }\n        }\n        viewModelScope.launch {\n            AppService.isPlay.collect { isPlay -\u003e\n                _state.update { it.copy(isPlay \u003d isPlay) }\n            }\n        }\n        viewModelScope.launch {\n            AppService.isShuffle.collect { isShuffle -\u003e\n                _state.update { it.copy(isShuffle \u003d isShuffle) }\n            }\n        }\n        viewModelScope.launch {\n            AppService.isRepeat.collect { isRepeat -\u003e\n                _state.update { it.copy(isRepeat \u003d isRepeat) }\n            }\n        }\n    }\n\n    fun processIntent(intent: MviIntent) {\n        viewModelScope.launch {\n            when (intent) {\n                is MviIntent.GetUser -\u003e {\n                    getUser(intent.userId)\n                }\n\n                is MviIntent.OnClickSignup -\u003e {\n                    sendEvent(MviEvent.GotoSignup)\n                }\n\n                is MviIntent.CheckLogin -\u003e {\n                    checkLogin(intent.userInfo, intent.context)\n                }\n\n                is MviIntent.CheckSignup -\u003e {\n                    checkSignup(intent.userInfo)\n                }\n\n                is MviIntent.OnClickProfile -\u003e {\n                    sendEvent(MviEvent.GotoProfile)\n                }\n\n                is MviIntent.EditProfile -\u003e {\n                    editProfile(intent.userInfo)\n                }\n\n                is MviIntent.OnLogout -\u003e {\n                    logout(intent.context)\n                }\n\n                is MviIntent.OnClickSetting -\u003e {\n                    sendEvent(MviEvent.GotoSettings)\n                }\n\n                is MviIntent.ChangeTheme -\u003e {\n                    _state.value \u003d _state.value.copy(darkTheme \u003d !_state.value.darkTheme)\n                }\n\n                is MviIntent.LoadMusicData -\u003e {\n                    _state.value \u003d _state.value.copy(\n                        topAlbums \u003d getTopAlbums(),\n                        topTracks \u003d getTopTracks(),\n                        topArtists \u003d getTopArtists()\n                    )\n                }\n\n                is MviIntent.OnClickSeeAllTopAlbums -\u003e {\n                    sendEvent(MviEvent.GotoTopAlbums)\n                }\n\n                is MviIntent.OnClickSeeAllTopTracks -\u003e {\n                    sendEvent(MviEvent.GotoTopTracks)\n                }\n\n                is MviIntent.OnClickSeeAllTopArtists -\u003e {\n                    sendEvent(MviEvent.GotoTopArtists)\n                }\n\n                is MviIntent.LoadPlaylistsOfUser -\u003e {\n                    _state.value \u003d _state.value.copy(playlists \u003d loadPlaylistOfUser())\n                }\n\n                is MviIntent.LoadSongLocal -\u003e {\n                    val songs \u003d withContext(Dispatchers.IO) {\n                        getSongExternal(intent.context)\n                    }\n                    _state.value \u003d _state.value.copy(listSongLocal \u003d songs)\n                }\n\n                is MviIntent.LoadSongRemote -\u003e {\n                    loadSongRemote(intent.context)\n                }\n\n                is MviIntent.CreatePlaylist -\u003e {\n                    createPlaylist(intent.title)\n                }\n\n                is MviIntent.RenamePlaylist -\u003e {\n                    playlistRepository.renamePlaylist(intent.playlist.id, intent.title)\n                    _state.value \u003d _state.value.copy(playlists \u003d loadPlaylistOfUser())\n                }\n\n                is MviIntent.RemovePlaylist -\u003e {\n                    removePlaylist(intent.context, intent.playlist)\n                }\n\n                is MviIntent.AddSongToPlaylist -\u003e {\n                    addSongToPlaylist(intent.context, intent.song, intent.playlist)\n                }\n\n                is MviIntent.RemoveSongInPlaylist -\u003e {\n                    removeSongInPlaylist(intent.context, intent.song, intent.playlist)\n                }\n\n                is MviIntent.OnClickPlaylistDetail -\u003e {\n                    sendEvent(MviEvent.GotoPlaylistDetail(intent.playlistId))\n                }\n\n                is MviIntent.OnClickPlayer -\u003e {\n                    playSong(intent.song,intent.playerListSong,intent.playerPlaylist,intent.context)\n                }\n\n                is MviIntent.OnChangeSongPlayState -\u003e {\n                    onPauseResume(intent.context)\n                }\n\n                is MviIntent.OnClickNextSong -\u003e {\n                    val tmpIntent \u003d Intent(intent.context, AppService::class.java).apply {\n                        action \u003d AppService.ACTION_NEXT\n                    }\n                    intent.context.startForegroundService(tmpIntent)\n                }\n\n                is MviIntent.OnClickPreviousSong -\u003e {\n                    val tmpIntent \u003d Intent(intent.context, AppService::class.java).apply {\n                        action \u003d AppService.ACTION_PREVIOUS\n                    }\n                    intent.context.startForegroundService(tmpIntent)\n                }\n\n                is MviIntent.OnClickShuffle -\u003e {\n                    val tmpIntent \u003d Intent(intent.context, AppService::class.java).apply {\n                        action \u003d AppService.ACTION_SHUFFLE\n                    }\n                    intent.context.startForegroundService(tmpIntent)\n                }\n\n                is MviIntent.OnClickRepeat -\u003e {\n                    val tmpIntent \u003d Intent(intent.context, AppService::class.java).apply {\n                        action \u003d AppService.ACTION_REPEAT\n                    }\n                    intent.context.startForegroundService(tmpIntent)\n                }\n\n                is MviIntent.OnClickClosePlayer -\u003e {\n                    val tmpIntent \u003d Intent(intent.context, AppService::class.java).apply {\n                        action \u003d AppService.ACTION_CLOSE\n                    }\n                    intent.context.startForegroundService(tmpIntent)\n                }\n            }\n        }\n    }\n\n    private fun sendEvent(event: MviEvent) {\n        viewModelScope.launch {\n            _event.emit(event)\n        }\n    }\n\n    private suspend fun getUser(userId: Long) {\n        val user \u003d withContext(Dispatchers.IO) {\n            userRepository.getUserById(userId)\n        }\n        _state.value \u003d _state.value.copy(userInfo \u003d user!!.toUserInfo())\n    }\n\n    private suspend fun checkLogin(userInfo: UserInfo, context: Context) {\n        val user \u003d withContext(Dispatchers.IO) {\n            userRepository.login(userInfo.username, userInfo.password)\n        }\n        if (user !\u003d null) {\n            _state.value \u003d _state.value.copy(userInfo \u003d user.toUserInfo())\n            AppUtils.saveUser(context, user.userId)\n            sendEvent(MviEvent.GotoHome)\n        } else {\n            sendEvent(MviEvent.ShowToast(\&quot;Login failed\&quot;))\n        }\n    }\n\n    private suspend fun checkSignup(userInfo: UserInfo) {\n        try {\n            val result \u003d withContext(Dispatchers.IO) {\n                userRepository.signup(\n                    username \u003d userInfo.username,\n                    password \u003d userInfo.password,\n                    email \u003d userInfo.email\n                )\n            }\n            if (result \u003e 0) {\n                sendEvent(MviEvent.GotoLogin)\n            } else {\n                sendEvent(MviEvent.ShowToast(\&quot;Username already exists\&quot;))\n            }\n        } catch (e: Exception) {\n            sendEvent(MviEvent.ShowToast(\&quot;Signup failed ${e.message}\&quot;))\n        }\n    }\n\n    private suspend fun editProfile(userInfo: UserInfo) {\n        withContext(Dispatchers.IO) {\n            userRepository.updateUser(userInfo.toUserEntity())\n        }\n        _state.value \u003d _state.value.copy(userInfo \u003d userInfo)\n    }\n\n    private fun logout(context: Context) {\n        AppUtils.clear(context)\n        AppUtils.setAppLanguage(\&quot;en\&quot;, context)\n        val tmpIntent \u003d Intent(context, AppService::class.java).apply {\n            action \u003d AppService.ACTION_CLOSE\n        }\n        context.startService(tmpIntent)\n        _state.value \u003d MviState()\n        sendEvent(MviEvent.GotoLogin)\n    }\n\n    private suspend fun loadSongRemote(context: Context){\n        val dir \u003d File(context.filesDir, _state.value.userInfo.username)\n        if (!dir.exists()) {\n            val songApi \u003d getSongRemote()\n            //delay(1000) // neu k co delay thi songApi \u003d null, vi interface ApiService dunng Call\u003cList\u003cSongRemote\u003e\u003e\n            val songInternal \u003d mutableListOf\u003cSong\u003e()\n            withContext(Dispatchers.IO) {\n                for (i in songApi) {\n                    songInternal.add(\n                        downloadSongToInternalStorage(\n                            context, i.path!!, _state.value.userInfo.username, i.title + \&quot;.mp3\&quot;\n                        )!!\n                    )\n                }\n            }\n            _state.value \u003d _state.value.copy(listSongRemote \u003d songInternal)\n        } else {\n            val songs \u003d\n                getALlSongInternal(context, _state.value.userInfo.username)\n            _state.value \u003d _state.value.copy(listSongRemote \u003d songs)\n        }\n    }\n\n    private suspend fun createPlaylist(title: String){\n        val playlistEntity \u003d PlaylistEntity(\n            title \u003d title,\n            userId \u003d _state.value.userInfo.id\n        )\n        playlistRepository.createPlaylist(playlistEntity)\n        _state.value \u003d _state.value.copy(playlists \u003d loadPlaylistOfUser())\n    }\n\n    private suspend fun loadPlaylistOfUser(): List\u003cPlaylist\u003e {\n        val playlists \u003d mutableListOf\u003cPlaylist\u003e()\n        withContext(Dispatchers.IO) {\n            val playlistWithSongsList \u003d\n                playlistRepository.getPlaylistsWithSongsOfUser(_state.value.userInfo.id)\n            playlistWithSongsList.map {\n                val songs \u003d it.songs.map { songEntity -\u003e\n                    Song(\n                        id \u003d songEntity.songId,\n                        title \u003d songEntity.title,\n                        artist \u003d songEntity.artist,\n                        duration \u003d songEntity.duration,\n                        uri \u003d songEntity.uri,\n                        img \u003d songEntity.img\n                    )\n                }\n                playlists.add(\n                    Playlist(\n                        id \u003d it.playlist.playlistId,\n                        title \u003d it.playlist.title,\n                        listSong \u003d songs.toMutableList()\n                    )\n                )\n            }\n        }\n        return playlists\n    }\n\n    private suspend fun getSongExternal(context: Context): MutableList\u003cSong\u003e {\n        val songs \u003d mutableListOf\u003cSong\u003e()\n        withContext(Dispatchers.IO) {\n            val uri \u003d MediaStore.Audio.Media.EXTERNAL_CONTENT_URI\n            val projection \u003d arrayOf(\n                MediaStore.Audio.Media._ID,\n                MediaStore.Audio.Media.TITLE,\n                MediaStore.Audio.Media.ARTIST,\n                MediaStore.Audio.Media.DURATION,\n                MediaStore.Audio.Albums.ALBUM_ID\n            )\n\n            val selection \u003d \&quot;${MediaStore.Audio.Media.IS_MUSIC} !\u003d 0\&quot;\n\n            val cursor \u003d context.contentResolver.query(\n                uri, projection, selection, null, null\n            )\n            cursor?.use {\n                val idColumn \u003d it.getColumnIndexOrThrow(MediaStore.Audio.Media._ID)\n                val titleColumn \u003d it.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE)\n                val artistColumn \u003d it.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST)\n                val durationColumn \u003d it.getColumnIndexOrThrow(MediaStore.Audio.Media.DURATION)\n                val albumIdColumn \u003d it.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM_ID)\n\n                while (it.moveToNext()) {\n                    val id \u003d it.getLong(idColumn)\n                    val title \u003d it.getString(titleColumn)\n                    val artist \u003d it.getString(artistColumn)\n                    val duration \u003d it.getLong(durationColumn)\n                    val albumId \u003d it.getLong(albumIdColumn)\n                    val songUri \u003d\n                        ContentUris.withAppendedId(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, id)\n                    val img \u003d AppUtils.getAlbumArt(context, albumId)\n                    songs.add(Song(id, title, artist, duration, songUri, img))\n                }\n            }\n        }\n        return songs\n    }\n\n    private suspend fun getALlSongInternal(\n        context: Context,\n        folderName: String\n    ): MutableList\u003cSong\u003e {\n        val songs \u003d mutableListOf\u003cSong\u003e()\n        val dir \u003d File(context.filesDir, folderName)\n        val mp3 \u003d dir.listFiles() ?: return mutableListOf()\n\n        withContext(Dispatchers.IO) {\n            val retriever \u003d MediaMetadataRetriever()\n            for (i in mp3) {\n                try {\n                    retriever.setDataSource(i.absolutePath)\n                    val title \u003d retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_TITLE)\n                        ?: i.nameWithoutExtension\n                    val artist \u003d\n                        retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ARTIST)\n                            ?: \&quot;Unknown Artist\&quot;\n                    val duration \u003d\n                        retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION)\n                            ?.toLongOrNull() ?: 0L\n                    val path \u003d i.absolutePath\n                    val img \u003d retriever.embeddedPicture\n                    songs.add(\n                        Song(\n                            title \u003d title,\n                            artist \u003d artist,\n                            duration \u003d duration,\n                            uri \u003d Uri.fromFile(i),\n                            img \u003d img,\n                            path \u003d path\n                        )\n                    )\n                } catch (e: Exception) {\n                    Log.d(\&quot;getSongInternal\&quot;, e.toString())\n                }\n            }\n        }\n        return songs\n    }\n\n    private suspend fun getSongRemote(): MutableList\u003cSong\u003e \u003d withContext(Dispatchers.IO) {\n        return@withContext try {\n            ApiSongClient.build().getSongRemote().map { it.toSong() }.toMutableList()\n        } catch (e: UnknownHostException) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Khong co mang: ${e.message}\&quot;)\n            mutableListOf()\n        } catch (e: IOException) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Loi IO: ${e.message}\&quot;)\n            mutableListOf()\n        } catch (e: Exception) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Loi khac: ${e.message}\&quot;)\n            mutableListOf()\n        }\n    }\n\n    private suspend fun getTopAlbums(): TopAlbums? \u003d withContext(Dispatchers.IO) {\n        return@withContext try {\n            ApiMusicClient.build().getTopAlbums().topalbums\n        } catch (e: UnknownHostException) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Khong co mang: ${e.message}\&quot;)\n            null\n        } catch (e: IOException) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Loi IO: ${e.message}\&quot;)\n            null\n        } catch (e: Exception) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Loi khac: ${e.message}\&quot;)\n            null\n        }\n    }\n\n    private suspend fun getTopTracks(): TopTracks? \u003d withContext(Dispatchers.IO) {\n        return@withContext try {\n            ApiMusicClient.build().getTopTracks().toptracks\n        } catch (e: UnknownHostException) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Khong co mang: ${e.message}\&quot;)\n            null\n        } catch (e: IOException) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Loi IO: ${e.message}\&quot;)\n            null\n        } catch (e: Exception) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Loi khac: ${e.message}\&quot;)\n            null\n        }\n    }\n\n    private suspend fun getTopArtists(): TopArtists? \u003d withContext(Dispatchers.IO) {\n        return@withContext try {\n            ApiMusicClient.build().getTopArtists().topArtists\n        } catch (e: UnknownHostException) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Khong co mang: ${e.message}\&quot;)\n            null\n        } catch (e: IOException) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Loi IO: ${e.message}\&quot;)\n            null\n        } catch (e: Exception) {\n            Log.d(\&quot;API_ERROR\&quot;, \&quot;Loi khac: ${e.message}\&quot;)\n            null\n        }\n    }\n\n    private suspend fun removeSongInPlaylist(context: Context, song: Song, playlist: Playlist) {\n        withContext(Dispatchers.IO) {\n            playlistRepository.removeSongInPlaylist(song.id, playlist.id)\n            _state.value \u003d _state.value.copy(playlists \u003d loadPlaylistOfUser())\n            if (_state.value.playerPlaylist?.id \u003d\u003d playlist.id) {\n                val newPlaylist \u003d _state.value.playlists.find {\n                    it.id \u003d\u003d playlist.id\n                }\n                if (song.id \u003d\u003d _state.value.playerSong?.id) {\n                    Log.d(\&quot;HungDM\&quot;, \&quot;chay not bai day di\&quot;)\n                }\n                val tmpIntent \u003d Intent(context, AppService::class.java).apply {\n                    action \u003d AppService.ACTION_UPDATE\n                    putExtra(AppService.EXTRA_PLAYLIST, newPlaylist)\n                }\n                context.startForegroundService(tmpIntent)\n            }\n        }\n    }\n\n    private suspend fun addSongToPlaylist(context: Context, song: Song, playlist: Playlist) {\n        withContext(Dispatchers.IO) {\n            val id \u003d playlistRepository.addSong(song.toSongEntity())\n            playlistRepository.addSongToPlaylist(\n                PlaylistSongReference(playlist.id, id)\n            )\n            _state.value \u003d _state.value.copy(playlists \u003d loadPlaylistOfUser())\n            if (_state.value.playerPlaylist?.id \u003d\u003d playlist.id) {\n                val newPlaylist \u003d _state.value.playlists.find {\n                    it.id \u003d\u003d playlist.id\n                }\n                val tmpIntent \u003d Intent(context, AppService::class.java).apply {\n                    action \u003d AppService.ACTION_UPDATE\n                    putExtra(AppService.EXTRA_PLAYLIST, newPlaylist)\n                }\n                context.startForegroundService(tmpIntent)\n            }\n        }\n    }\n\n    private suspend fun removePlaylist(context: Context, playlist: Playlist) {\n        withContext(Dispatchers.IO) {\n            playlistRepository.removePlaylist(playlist.id)\n            playlistRepository.removeAllSongInPlaylist(playlist.id)\n            _state.value \u003d _state.value.copy(playlists \u003d loadPlaylistOfUser())\n            if (_state.value.playerPlaylist?.id \u003d\u003d playlist.id) {\n                val tmpIntent \u003d Intent(context, AppService::class.java).apply {\n                    action \u003d AppService.ACTION_CLOSE\n                }\n                context.startForegroundService(tmpIntent)\n            }\n        }\n    }\n\n    private fun playSong(song: Song, playerListSong: List\u003cSong\u003e?, playerPlaylist: Playlist?, context: Context){\n        val playerSongIndex \u003d playerListSong?.indexOf(song) ?: playerPlaylist!!.listSong.indexOf(song)\n        val tmpIntent \u003d Intent(context, AppService::class.java).apply {\n            action \u003d AppService.ACTION_PLAY\n            putExtra(AppService.EXTRA_PLAYLIST, playerPlaylist)\n            putExtra(\n                AppService.EXTRA_LIST_SONG, ArrayList(playerListSong ?: emptyList())\n            )\n            putExtra(AppService.EXTRA_SONG, song)\n            putExtra(AppService.EXTRA_INDEX, playerSongIndex)\n        }\n        context.startForegroundService(tmpIntent)\n    }\n\n    private fun onPauseResume(context: Context){\n        if (_state.value.isPlay) {\n            val tmpIntent \u003d Intent(context, AppService::class.java).apply {\n                action \u003d AppService.ACTION_PAUSE\n            }\n            context.startForegroundService(tmpIntent)\n        } else {\n            val tmpIntent \u003d Intent(context, AppService::class.java).apply {\n                action \u003d AppService.ACTION_RESUME\n            }\n            context.startForegroundService(tmpIntent)\n        }\n    }\n\n    private suspend fun downloadSongToInternalStorage(\n        context: Context,\n        fileUrl: String,\n        folderName: String,\n        fileName: String\n    ): Song? {\n        val dir \u003d File(context.filesDir, folderName)\n        if (!dir.exists()) dir.mkdir()\n        val file \u003d File(dir, fileName)\n        if (file.exists()) return null\n\n        return try {\n            var song: Song?\n            withContext(Dispatchers.IO) {\n                val url \u003d URL(fileUrl)\n                val connection \u003d withContext(Dispatchers.IO) {\n                    url.openConnection()\n                } as HttpURLConnection\n                connection.connectTimeout \u003d 5000\n                connection.readTimeout \u003d 5000\n                connection.requestMethod \u003d \&quot;GET\&quot;\n                connection.doInput \u003d true\n                connection.connect()\n\n                if (connection.responseCode !\u003d HttpURLConnection.HTTP_OK) {\n                    throw IOException(\&quot;HTTP error code: ${connection.responseCode}\&quot;)\n                }\n\n                val inputStream \u003d BufferedInputStream(connection.inputStream)\n                val outputStream \u003d FileOutputStream(file)\n\n                inputStream.use { input -\u003e\n                    outputStream.use { output -\u003e\n                        input.copyTo(output)\n                    }\n                }\n\n                val retriever \u003d MediaMetadataRetriever()\n                retriever.setDataSource(file.absolutePath)\n\n                val title \u003d retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_TITLE)\n                    ?: file.nameWithoutExtension\n                val artist \u003d retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ARTIST)\n                    ?: \&quot;Unknown Artist\&quot;\n                val duration \u003d\n                    retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION)\n                        ?.toLongOrNull() ?: 0L\n                val uri \u003d Uri.fromFile(file)\n                val img \u003d retriever.embeddedPicture\n                val path \u003d file.absolutePath\n                song \u003d Song(\n                    title \u003d title,\n                    artist \u003d artist,\n                    duration \u003d duration,\n                    uri \u003d uri,\n                    img \u003d img,\n                    path \u003d path\n                )\n            }\n            song\n        } catch (e: Exception) {\n            e.printStackTrace()\n            null\n        }\n    }\n}\n```\n\u003c/current_file\u003e\n\n\n\u003cattached_files\u003e\n\u003cfile_contents\u003e\n```kotlin:app/src/main/java/com/example/hungdm/service/AppService.kt, lines\u003dALL(1-262)\npackage com.example.hungdm.service\n\nimport android.content.Intent\nimport android.media.MediaPlayer\nimport android.os.IBinder\nimport android.util.Log\nimport androidx.lifecycle.LifecycleService\nimport androidx.lifecycle.lifecycleScope\nimport com.example.hungdm.domain.model.Playlist\nimport com.example.hungdm.domain.model.Song\nimport kotlinx.coroutines.Job\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.isActive\nimport kotlinx.coroutines.launch\nimport kotlin.random.Random\nimport kotlin.random.nextInt\n\nclass AppService : LifecycleService() {\n\n    companion object {\n        const val ACTION_PLAY \u003d \&quot;ACTION_PLAY\&quot;\n        const val ACTION_PAUSE \u003d \&quot;ACTION_PAUSE\&quot;\n        const val ACTION_RESUME \u003d \&quot;ACTION_RESUME\&quot;\n        const val ACTION_CLOSE \u003d \&quot;ACTION_CLOSE\&quot;\n        const val ACTION_NEXT \u003d \&quot;ACTION_NEXT\&quot;\n        const val ACTION_PREVIOUS \u003d \&quot;ACTION_PREVIOUS\&quot;\n        const val ACTION_UPDATE \u003d \&quot;ACTION_UPDATE\&quot;\n        const val ACTION_SHUFFLE \u003d \&quot;ACTION_SHUFFLE\&quot;\n        const val ACTION_REPEAT \u003d \&quot;ACTION_REPEAT\&quot;\n        const val EXTRA_PLAYLIST \u003d \&quot;EXTRA_PLAYLIST\&quot;\n        const val EXTRA_LIST_SONG \u003d \&quot;EXTRA_LIST_SONG\&quot;\n        const val EXTRA_INDEX \u003d \&quot;EXTRA_INDEX\&quot;\n        const val EXTRA_SONG \u003d \&quot;EXTRA_SONG\&quot;\n\n        val playerPlaylist: MutableStateFlow\u003cPlaylist?\u003e \u003d MutableStateFlow(null)\n        val playerListSong: MutableStateFlow\u003cList\u003cSong\u003e?\u003e \u003d MutableStateFlow(null)\n        val playerSongIndex: MutableStateFlow\u003cInt?\u003e \u003d MutableStateFlow(null)\n        val playerSong: MutableStateFlow\u003cSong?\u003e \u003d MutableStateFlow(null)\n        val playerTime: MutableStateFlow\u003cLong\u003e \u003d MutableStateFlow(0L)\n        val isPlay: MutableStateFlow\u003cBoolean\u003e \u003d MutableStateFlow(false)\n        val isShuffle: MutableStateFlow\u003cBoolean\u003e \u003d MutableStateFlow(false)\n        val isRepeat: MutableStateFlow\u003cBoolean\u003e \u003d MutableStateFlow(false)\n    }\n\n    private var mediaPlayer: MediaPlayer? \u003d null\n    private var notificationHelper: NotificationHelper? \u003d null\n    private var timeJob: Job? \u003d null\n\n    override fun onCreate() {\n        super.onCreate()\n        notificationHelper \u003d NotificationHelper(this)\n    }\n\n    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {\n        super.onStartCommand(intent, flags, startId)\n        when (intent?.action) {\n            ACTION_PLAY -\u003e {\n                playerPlaylist.value \u003d intent.getParcelableExtra\u003cPlaylist\u003e(EXTRA_PLAYLIST)\n                playerListSong.value \u003d intent.getParcelableArrayListExtra\u003cSong\u003e(EXTRA_LIST_SONG)\n                playerSongIndex.value \u003d intent.getIntExtra(EXTRA_INDEX,0)\n                playerSong.value \u003d intent.getParcelableExtra\u003cSong\u003e(EXTRA_SONG)\n                playerTime.value \u003d 0L\n                isPlay.value \u003d true\n                playSong()\n            }\n            ACTION_PAUSE -\u003e {\n                isPlay.value \u003d false\n                pauseSong()\n            }\n            ACTION_CLOSE -\u003e {\n                playerPlaylist.value \u003d null\n                playerListSong.value \u003d null\n                playerSongIndex.value \u003d null\n                playerSong.value \u003d null\n                playerTime.value \u003d 0L\n                isPlay.value \u003d false\n                closeSong()\n            }\n            ACTION_RESUME -\u003e {\n                isPlay.value \u003d true\n                resumeSong()\n            }\n            ACTION_NEXT -\u003e {\n                if(isShuffle.value){\n                    shuffleSong()\n                } else if(isRepeat.value){\n                    repeatSong()\n                } else nextSong()\n\n            }\n            ACTION_PREVIOUS -\u003e {\n                if(isShuffle.value){\n                    shuffleSong()\n                } else if(isRepeat.value){\n                    repeatSong()\n                } else previousSong()\n            }\n            ACTION_SHUFFLE -\u003e {\n                isShuffle.value \u003d !isShuffle.value\n                isRepeat.value \u003d false\n            }\n            ACTION_REPEAT -\u003e {\n                isRepeat.value \u003d !isRepeat.value\n                isShuffle.value \u003d false\n            }\n            ACTION_UPDATE -\u003e {\n                playerPlaylist.value \u003d intent.getParcelableExtra\u003cPlaylist\u003e(EXTRA_PLAYLIST)\n            }\n        }\n        return START_STICKY\n    }\n\n    override fun onDestroy() {\n        mediaPlayer?.release()\n        mediaPlayer \u003d null\n        stopForeground(true)\n        super.onDestroy()\n    }\n\n    private fun playSong() {\n        try {\n            mediaPlayer?.release()\n            mediaPlayer \u003d MediaPlayer().apply {\n                setDataSource(applicationContext, playerSong.value?.uri!!)\n                prepare()\n                start()\n                isLooping \u003d false\n                setOnCompletionListener {\n                    if(isShuffle.value){\n                        shuffleSong()\n                    } else if(isRepeat.value){\n                        repeatSong()\n                    } else nextSong()\n                }\n            }\n            isPlay.value \u003d true\n            startUpdatingTime()\n            startForeground(\n                1,\n                notificationHelper?.createNotification(playerSong.value?.title!!, isPlay.value)\n            )\n        } catch (e: Exception) {\n            e.printStackTrace()\n        }\n    }\n\n    private fun pauseSong() {\n        timeJob?.cancel()\n        mediaPlayer?.pause()\n        startForeground(\n            1,\n            notificationHelper?.createNotification(playerSong.value?.title!!, isPlay.value)\n        )\n    }\n\n    private fun closeSong() {\n        mediaPlayer?.stop()\n        mediaPlayer?.release()\n        mediaPlayer \u003d null\n        notificationHelper \u003d null\n        stopSelf()\n    }\n\n    private fun resumeSong() {\n        mediaPlayer?.let {\n            if (!it.isPlaying) {\n                it.start()\n                startUpdatingTime()\n                startForeground(\n                    1,\n                    notificationHelper?.createNotification(playerSong.value?.title!!, isPlay.value)\n                )\n            }\n        }\n    }\n\n    private fun nextSong() {\n        if(playerPlaylist.value\u003d\u003dnull){\n            val nextIndex \u003d if (playerSongIndex.value!! \u003e\u003d playerListSong.value!!.size - 1) 0 else playerSongIndex.value!! + 1\n\n            playerSongIndex.value \u003d nextIndex\n            playerSong.value \u003d playerListSong.value!![nextIndex]\n            playerTime.value \u003d 0L\n        } else {\n            val nextIndex \u003d if (playerSongIndex.value!! \u003e\u003d playerPlaylist.value!!.listSong.size - 1) 0 else playerSongIndex.value!! + 1\n\n            playerSongIndex.value \u003d nextIndex\n            playerSong.value \u003d playerPlaylist.value!!.listSong[nextIndex]\n            playerTime.value \u003d 0L\n        }\n\n        playSong()\n    }\n\n    private fun previousSong(){\n        if(playerPlaylist.value\u003d\u003dnull){\n            val preIndex \u003d if (playerSongIndex.value!! \u003c\u003d 0) playerListSong.value!!.size - 1 else playerSongIndex.value!! - 1\n\n            playerSongIndex.value \u003d preIndex\n            playerSong.value \u003d playerListSong.value!![preIndex]\n            playerTime.value \u003d 0L\n        } else {\n            val preIndex \u003d if (playerSongIndex.value!! \u003c\u003d 0) playerPlaylist.value!!.listSong.size - 1 else playerSongIndex.value!! - 1\n\n            playerSongIndex.value \u003d preIndex\n            playerSong.value \u003d playerPlaylist.value!!.listSong[preIndex]\n            playerTime.value \u003d 0L\n        }\n\n        playSong()\n    }\n\n    private fun shuffleSong() {\n        if(playerPlaylist.value\u003d\u003dnull){\n            val nextIndex \u003d Random.nextInt(0, playerListSong.value!!.size)\n\n            playerSongIndex.value \u003d nextIndex\n            playerSong.value \u003d playerListSong.value!![nextIndex]\n            playerTime.value \u003d 0L\n        } else {\n            val nextIndex \u003d Random.nextInt(0, playerPlaylist.value!!.listSong.size)\n\n            playerSongIndex.value \u003d nextIndex\n            playerSong.value \u003d playerPlaylist.value!!.listSong[nextIndex]\n            playerTime.value \u003d 0L\n        }\n\n        playSong()\n    }\n\n    private fun repeatSong() {\n        if(playerPlaylist.value\u003d\u003dnull){\n            val nextIndex \u003d playerSongIndex.value!!\n\n            playerSongIndex.value \u003d nextIndex\n            playerSong.value \u003d playerListSong.value!![nextIndex]\n            playerTime.value \u003d 0L\n        } else {\n            val nextIndex \u003d playerSongIndex.value!!\n\n            playerSongIndex.value \u003d nextIndex\n            playerSong.value \u003d playerPlaylist.value!!.listSong[nextIndex]\n            playerTime.value \u003d 0L\n        }\n\n        playSong()\n    }\n\n\n    private fun startUpdatingTime() {\n        timeJob?.cancel()\n        timeJob \u003d lifecycleScope.launch {\n            while (isActive) {\n                val time \u003d mediaPlayer?.currentPosition?.toLong() ?: 0L\n                playerTime.value \u003d time\n                delay(100)\n            }\n        }\n    }\n}\n\n```\n\u003c/file_contents\u003e\n\n\u003c/attached_files\u003e\n\u003c/additional_data\u003e\n\u003cuser_query\u003e\nbạn đọc code của tôi và có thấy vấn đề nào không\n\u003c/user_query\u003e&quot;}]},{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;\n\u003cadditional_data\u003e\nBelow are some potentially helpful/relevant pieces of information for figuring out to respond\n\u003ccurrent_file\u003e\n```kotlin:app/src/main/java/com/example/hungdm/mvi/MviViewModel.kt, lines\u003dALL(1-657)\n(file is identical to original version)\n```\n\u003c/current_file\u003e\n\n\n\u003cattached_files\u003e\n\u003cfile_contents\u003e\n```kotlin:app/src/main/java/com/example/hungdm/service/AppService.kt, lines\u003dALL(1-262)\n(file is identical to original version)\n```\n\u003c/file_contents\u003e\n\n\u003c/attached_files\u003e\n\u003c/additional_data\u003e\n\u003cuser_query\u003e\nbạn đọc code của tôi và có thấy vấn đề nào không\n\u003c/user_query\u003e&quot;}]},{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;\u003cuser_query\u003e\nhiểu tiếng việt không\n\u003c/user_query\u003e&quot;}]}]}" />
      </map>
    </option>
  </component>
</project>